<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Find the Largest k Singular Values/Vectors of a Matrix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for svds {RSpectra}"><tr><td>svds {RSpectra}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Find the Largest k Singular Values/Vectors of a Matrix</h2>

<h3>Description</h3>

<p>Given an <i>m</i> by <i>n</i> matrix <i>A</i>,
function <code>svds()</code> can find its largest <i>k</i>
singular values and the corresponding singular vectors.
It is also called the Truncated SVD or Partial SVD
since it only calculates a subset of the whole singular triplets.
</p>
<p>Currently <code>svds()</code> supports matrices of the following classes:
</p>

<table summary="Rd table">
<tr>
 <td style="text-align: left;">
  <code>matrix</code>     </td><td style="text-align: left;"> The most commonly used matrix type,
                         defined in the <strong>base</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dgeMatrix</code>  </td><td style="text-align: left;"> General matrix, equivalent to <code>matrix</code>,
                         defined in the <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dgCMatrix</code>  </td><td style="text-align: left;"> Column oriented sparse matrix, defined in
                         the <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dgRMatrix</code>  </td><td style="text-align: left;"> Row oriented sparse matrix, defined in
                         the <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dsyMatrix</code>  </td><td style="text-align: left;"> Symmetrix matrix, defined in the <strong>Matrix</strong>
                         package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dsCMatrix</code>  </td><td style="text-align: left;"> Symmetric column oriented sparse matrix, defined in
                         the <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dsRMatrix</code>  </td><td style="text-align: left;"> Symmetric row oriented sparse matrix, defined in
                         the <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>function</code>   </td><td style="text-align: left;"> Implicitly specify the matrix through two
                         functions that calculate
                         <i>f(x) = A * x</i> and
                         <i>g(x) = A' * x</i>. See section
                         <strong>Function Interface</strong> for details.
</td>
</tr>

</table>

<p>Note that when <i>A</i> is symmetric and positive semi-definite,
SVD reduces to eigen decomposition, so you may consider using
<code><a href="../../RSpectra/help/eigs.html">eigs</a>()</code> instead. When <i>A</i> is symmetric but
not necessarily positive semi-definite, the left
and right singular vectors are the same as the left and right
eigenvectors, but the singular values and eigenvalues will
not be the same. In particular, if <i>&lambda;</i> is a negative
eigenvalue of <i>A</i>, then <i>|&lambda;|</i> will be the
corresponding singular value.
</p>


<h3>Usage</h3>

<pre>
svds(A, k, nu = k, nv = k, opts = list(), ...)

## S3 method for class 'matrix'
svds(A, k, nu = k, nv = k, opts = list(), ...)

## S3 method for class 'dgeMatrix'
svds(A, k, nu = k, nv = k, opts = list(), ...)

## S3 method for class 'dgCMatrix'
svds(A, k, nu = k, nv = k, opts = list(), ...)

## S3 method for class 'dgRMatrix'
svds(A, k, nu = k, nv = k, opts = list(), ...)

## S3 method for class 'dsyMatrix'
svds(A, k, nu = k, nv = k, opts = list(), ...)

## S3 method for class 'dsCMatrix'
svds(A, k, nu = k, nv = k, opts = list(), ...)

## S3 method for class 'dsRMatrix'
svds(A, k, nu = k, nv = k, opts = list(), ...)

## S3 method for class ''function''
svds(A, k, nu = k, nv = k, opts = list(), ..., Atrans, dim, args = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>A</code></td>
<td>
<p>The matrix whose truncated SVD is to be computed.</p>
</td></tr>
<tr valign="top"><td><code>k</code></td>
<td>
<p>Number of singular values requested.</p>
</td></tr>
<tr valign="top"><td><code>nu</code></td>
<td>
<p>Number of left singular vectors to be computed. This must
be between 0 and <code>k</code>.</p>
</td></tr>
<tr valign="top"><td><code>nv</code></td>
<td>
<p>Number of right singular vectors to be computed. This must
be between 0 and <code>k</code>.</p>
</td></tr>
<tr valign="top"><td><code>opts</code></td>
<td>
<p>Control parameters related to the computing
algorithm. See <strong>Details</strong> below.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Arguments for specialized S3 function calls, for example
<code>Atrans</code>, <code>dim</code> and <code>args</code>.</p>
</td></tr>
<tr valign="top"><td><code>Atrans</code></td>
<td>
<p>Only used when <code>A</code> is a function. <code>A</code> is a function
that calculates the matrix multiplication <i>A * x</i>, and
<code>Atrans</code> is a function that calculates the transpose
multiplication <i>A' * x</i>.</p>
</td></tr>
<tr valign="top"><td><code>dim</code></td>
<td>
<p>Only used when <code>A</code> is a function, to specify the
dimension of the implicit matrix. A vector of length two.</p>
</td></tr>
<tr valign="top"><td><code>args</code></td>
<td>
<p>Only used when <code>A</code> is a function. This argument
will be passed to the <code>A</code> and <code>Atrans</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>opts</code> argument is a list that can supply any of the
following parameters:
</p>

<dl>
<dt><code>ncv</code></dt><dd><p>Number of Lanzcos basis vectors to use. More vectors
will result in faster convergence, but with greater
memory use. <code>ncv</code> must be satisfy
<i>k &lt; ncv &lt;= p</i> where
<code>p = min(m, n)</code>.
Default is <code>min(p, max(2*k+1, 20))</code>.</p>
</dd>
<dt><code>tol</code></dt><dd><p>Precision parameter. Default is 1e-10.</p>
</dd>
<dt><code>maxitr</code></dt><dd><p>Maximum number of iterations. Default is 1000.</p>
</dd>
<dt><code>center</code></dt><dd><p>Either a logical value (<code>TRUE</code>/<code>FALSE</code>), or a numeric
vector of length <i>n</i>. If a vector <i>c</i> is supplied, then
SVD is computed on the matrix <i>A - 1 * c'</i>,
in an implicit way without actually forming this matrix.
<code>center = TRUE</code> has the same effect as
<code>center = colMeans(A)</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Either a logical value (<code>TRUE</code>/<code>FALSE</code>), or a numeric
vector of length <i>n</i>. If a vector <i>s</i> is supplied, then
SVD is computed on the matrix <i>(A - 1 * c')S</i>,
where <i>c</i> is the centering vector and <i>S = diag(1/s)</i>.
If <code>scale = TRUE</code>, then the vector <i>s</i> is computed as
the column norm of <i>A - 1 * c'</i>.
Default is <code>FALSE</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list with the following components:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>d</code></td>
<td>
<p>A vector of the computed singular values.</p>
</td></tr>
<tr valign="top"><td><code>u</code></td>
<td>
<p>An <code>m</code> by <code>nu</code> matrix whose columns contain
the left singular vectors. If <code>nu == 0</code>, <code>NULL</code>
will be returned.</p>
</td></tr>
<tr valign="top"><td><code>v</code></td>
<td>
<p>An <code>n</code> by <code>nv</code> matrix whose columns contain
the right singular vectors. If <code>nv == 0</code>, <code>NULL</code>
will be returned.</p>
</td></tr>
<tr valign="top"><td><code>nconv</code></td>
<td>
<p>Number of converged singular values.</p>
</td></tr>
<tr valign="top"><td><code>niter</code></td>
<td>
<p>Number of iterations used.</p>
</td></tr>
<tr valign="top"><td><code>nops</code></td>
<td>
<p>Number of matrix-vector multiplications used.</p>
</td></tr>
</table>


<h3>Function Interface</h3>

<p>The matrix <i>A</i> can be specified through two functions with
the following definitions
</p>
<pre>A &lt;- function(x, args)
{
    ## should return A %*% x
}

Atrans &lt;- function(x, args)
{
    ## should return t(A) %*% x
}</pre>
<p>They receive a vector <code>x</code> as an argument and returns a vector
of the proper dimension. These two functions should have the effect of
calculating <i>A * x</i> and <i>A' * x</i> respectively, and extra
arguments can be passed in through the
<code>args</code> parameter. In <code>svds()</code>, user should also provide
the dimension of the implicit matrix through the argument <code>dim</code>.
</p>
<p>The function interface does not support the <code>center</code> and <code>scale</code> parameters
in <code>opts</code>.
</p>


<h3>Author(s)</h3>

<p>Yixuan Qiu &lt;<a href="https://statr.me">https://statr.me</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="../../base/help/eigen.html">eigen</a>()</code>, <code><a href="../../base/help/svd.html">svd</a>()</code>,
<code><a href="../help/eigs.html">eigs</a>()</code>.
</p>


<h3>Examples</h3>

<pre>
m = 100
n = 20
k = 5
set.seed(111)
A = matrix(rnorm(m * n), m)

svds(A, k)
svds(t(A), k, nu = 0, nv = 3)

## Sparse matrices
library(Matrix)
A[sample(m * n, m * n / 2)] = 0
Asp1 = as(A, "dgCMatrix")
Asp2 = as(A, "dgRMatrix")

svds(Asp1, k)
svds(Asp2, k, nu = 0, nv = 0)

## Function interface
Af = function(x, args)
{
    as.numeric(args %*% x)
}

Atf = function(x, args)
{
    as.numeric(crossprod(args, x))
}

svds(Af, k, Atrans = Atf, dim = c(m, n), args = Asp1)

</pre>

<hr /><div style="text-align: center;">[Package <em>RSpectra</em> version 0.16-1 <a href="00Index.html">Index</a>]</div>
</div></body></html>
