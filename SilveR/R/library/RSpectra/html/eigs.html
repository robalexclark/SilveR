<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Find a Specified Number of Eigenvalues/vectors of a Square...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for eigs {RSpectra}"><tr><td>eigs {RSpectra}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Find a Specified Number of Eigenvalues/vectors of a Square Matrix</h2>

<h3>Description</h3>

<p>Given an <i>n</i> by <i>n</i> matrix <i>A</i>,
function <code>eigs()</code> can calculate a specified
number of eigenvalues and eigenvectors of <i>A</i>.
Users can specify the selection criterion by argument
<code>which</code>, e.g., choosing the <i>k</i> largest or smallest
eigenvalues and the corresponding eigenvectors.
</p>
<p>Currently <code>eigs()</code> supports matrices of the following classes:
</p>

<table summary="Rd table">
<tr>
 <td style="text-align: left;">
  <code>matrix</code>     </td><td style="text-align: left;"> The most commonly used matrix type,
                         defined in the <strong>base</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dgeMatrix</code>  </td><td style="text-align: left;"> General matrix, equivalent to <code>matrix</code>,
                         defined in the <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dgCMatrix</code>  </td><td style="text-align: left;"> Column oriented sparse matrix, defined in
                         the <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dgRMatrix</code>  </td><td style="text-align: left;"> Row oriented sparse matrix, defined in
                         the <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dsyMatrix</code>  </td><td style="text-align: left;"> Symmetric matrix, defined in the <strong>Matrix</strong>
                         package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dsCMatrix</code>  </td><td style="text-align: left;"> Symmetric column oriented sparse matrix, defined in
                         the <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>dsRMatrix</code>  </td><td style="text-align: left;"> Symmetric row oriented sparse matrix, defined in
                         the <strong>Matrix</strong> package.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>function</code>   </td><td style="text-align: left;"> Implicitly specify the matrix through a
                         function that has the effect of calculating
                         <i>f(x) = A * x</i>. See section
                         <strong>Function Interface</strong> for details.
</td>
</tr>

</table>

<p><code>eigs_sym()</code> assumes the matrix is symmetric,
and only the lower triangle (or upper triangle, which is
controlled by the argument <code>lower</code>) is used for
computation, which guarantees that the eigenvalues and eigenvectors are
real, and in general results in faster and more stable computation.
One exception is when <code>A</code> is a function, in which case the user is
responsible for the symmetry of the operator.
</p>
<p><code>eigs_sym()</code> supports &quot;matrix&quot;, &quot;dgeMatrix&quot;, &quot;dgCMatrix&quot;, &quot;dgRMatrix&quot;
and &quot;function&quot; typed matrices.
</p>


<h3>Usage</h3>

<pre>
eigs(A, k, which = "LM", sigma = NULL, opts = list(), ...)

## S3 method for class 'matrix'
eigs(A, k, which = "LM", sigma = NULL, opts = list(), ...)

## S3 method for class 'dgeMatrix'
eigs(A, k, which = "LM", sigma = NULL, opts = list(), ...)

## S3 method for class 'dsyMatrix'
eigs(A, k, which = "LM", sigma = NULL, opts = list(), ...)

## S3 method for class 'dgCMatrix'
eigs(A, k, which = "LM", sigma = NULL, opts = list(), ...)

## S3 method for class 'dsCMatrix'
eigs(A, k, which = "LM", sigma = NULL, opts = list(), ...)

## S3 method for class 'dgRMatrix'
eigs(A, k, which = "LM", sigma = NULL, opts = list(), ...)

## S3 method for class 'dsRMatrix'
eigs(A, k, which = "LM", sigma = NULL, opts = list(), ...)

## S3 method for class ''function''
eigs(
  A,
  k,
  which = "LM",
  sigma = NULL,
  opts = list(),
  ...,
  n = NULL,
  args = NULL
)

eigs_sym(A, k, which = "LM", sigma = NULL, opts = list(),
   lower = TRUE, ...)

## S3 method for class ''function''
eigs_sym(
  A,
  k,
  which = "LM",
  sigma = NULL,
  opts = list(),
  lower = TRUE,
  ...,
  n = NULL,
  args = NULL
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>A</code></td>
<td>
<p>The matrix whose eigenvalues/vectors are to be computed.
It can also be a function which receives a vector <i>x</i>
and calculates <i>A * x</i>.
See section <strong>Function Interface</strong> for details.</p>
</td></tr>
<tr valign="top"><td><code>k</code></td>
<td>
<p>Number of eigenvalues requested.</p>
</td></tr>
<tr valign="top"><td><code>which</code></td>
<td>
<p>Selection criterion. See <strong>Details</strong> below.</p>
</td></tr>
<tr valign="top"><td><code>sigma</code></td>
<td>
<p>Shift parameter. See section <strong>Shift-And-Invert Mode</strong>.</p>
</td></tr>
<tr valign="top"><td><code>opts</code></td>
<td>
<p>Control parameters related to the computing
algorithm. See <strong>Details</strong> below.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Arguments for specialized S3 function calls, for example
<code>lower</code>, <code>n</code> and <code>args</code>.</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p>Only used when <code>A</code> is a function, to specify the
dimension of the implicit matrix. See section
<strong>Function Interface</strong> for details.</p>
</td></tr>
<tr valign="top"><td><code>args</code></td>
<td>
<p>Only used when <code>A</code> is a function. This argument
will be passed to the <code>A</code> function when it is called.
See section <strong>Function Interface</strong> for details.</p>
</td></tr>
<tr valign="top"><td><code>lower</code></td>
<td>
<p>For symmetric matrices, should the lower triangle
or upper triangle be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>which</code> argument is a character string
that specifies the type of eigenvalues to be computed.
Possible values are:
</p>

<table summary="Rd table">
<tr>
 <td style="text-align: left;">
  "LM"  </td><td style="text-align: left;">  The <i>k</i> eigenvalues with largest magnitude. Here the
              magnitude means the Euclidean norm of complex numbers.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "SM"  </td><td style="text-align: left;">  The <i>k</i> eigenvalues with smallest magnitude.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "LR"  </td><td style="text-align: left;">  The <i>k</i> eigenvalues with largest real part.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "SR"  </td><td style="text-align: left;">  The <i>k</i> eigenvalues with smallest real part.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "LI"  </td><td style="text-align: left;">  The <i>k</i> eigenvalues with largest imaginary part.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "SI"  </td><td style="text-align: left;">  The <i>k</i> eigenvalues with smallest imaginary part.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "LA"  </td><td style="text-align: left;">  The <i>k</i> largest (algebraic) eigenvalues, considering any
              negative sign.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "SA"  </td><td style="text-align: left;">  The <i>k</i> smallest (algebraic) eigenvalues, considering any
              negative sign.</td>
</tr>
<tr>
 <td style="text-align: left;">
  "BE"  </td><td style="text-align: left;">  Compute <i>k</i> eigenvalues, half from each end of the
              spectrum. When <i>k</i> is odd, compute more from the high
              and then from the low end.
</td>
</tr>

</table>

<p><code>eigs()</code> with matrix types &quot;matrix&quot;, &quot;dgeMatrix&quot;, &quot;dgCMatrix&quot;
and &quot;dgRMatrix&quot; can use &quot;LM&quot;, &quot;SM&quot;, &quot;LR&quot;, &quot;SR&quot;, &quot;LI&quot; and &quot;SI&quot;.
</p>
<p><code>eigs_sym()</code> with all supported matrix types,
and <code>eigs()</code> with symmetric matrix types
(&quot;dsyMatrix&quot;, &quot;dsCMatrix&quot;, and &quot;dsRMatrix&quot;) can use &quot;LM&quot;, &quot;SM&quot;, &quot;LA&quot;, &quot;SA&quot; and &quot;BE&quot;.
</p>
<p>The <code>opts</code> argument is a list that can supply any of the
following parameters:
</p>

<dl>
<dt><code>ncv</code></dt><dd><p>Number of Lanzcos basis vectors to use. More vectors
will result in faster convergence, but with greater
memory use. For general matrix, <code>ncv</code> must satisfy
<i>k+2 &lt;= ncv &lt;= n</i>, and
for symmetric matrix, the constraint is
<i>k &lt; ncv &lt;= n</i>.
Default is <code>min(n, max(2*k+1, 20))</code>.</p>
</dd>
<dt><code>tol</code></dt><dd><p>Precision parameter. Default is 1e-10.</p>
</dd>
<dt><code>maxitr</code></dt><dd><p>Maximum number of iterations. Default is 1000.</p>
</dd>
<dt><code>retvec</code></dt><dd><p>Whether to compute eigenvectors. If FALSE,
only calculate and return eigenvalues.</p>
</dd>
<dt><code>initvec</code></dt><dd><p>Initial vector of length <i>n</i> supplied to the
Arnoldi/Lanczos iteration. It may speed up the convergence
if <code>initvec</code> is close to an eigenvector of <i>A</i>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list of converged eigenvalues and eigenvectors.
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>values</code></td>
<td>
<p>Computed eigenvalues.</p>
</td></tr>
<tr valign="top"><td><code>vectors</code></td>
<td>
<p>Computed eigenvectors. <code>vectors[, j]</code> corresponds to <code>values[j]</code>.</p>
</td></tr>
<tr valign="top"><td><code>nconv</code></td>
<td>
<p>Number of converged eigenvalues.</p>
</td></tr>
<tr valign="top"><td><code>niter</code></td>
<td>
<p>Number of iterations used in the computation.</p>
</td></tr>
<tr valign="top"><td><code>nops</code></td>
<td>
<p>Number of matrix operations used in the computation.</p>
</td></tr>
</table>


<h3>Shift-And-Invert Mode</h3>

<p>The <code>sigma</code> argument is used in the shift-and-invert mode.
</p>
<p>When <code>sigma</code> is not <code>NULL</code>, the selection criteria specified
by argument <code>which</code> will apply to
</p>
<p style="text-align: center;"><i>1/(&lambda;-&sigma;)</i></p>

<p>where <i>&lambda;</i>'s are the eigenvalues of <i>A</i>. This mode is useful
when user wants to find eigenvalues closest to a given number.
For example, if <i>&sigma;=0</i>, then <code>which = "LM"</code> will select the
largest values of <i>1/|&lambda;|</i>, which turns out to select
eigenvalues of <i>A</i> that have the smallest magnitude. The result of
using <code>which = "LM", sigma = 0</code> will be the same as
<code>which = "SM"</code>, but the former one is preferable
in that <code>eigs()</code> is good at finding large
eigenvalues rather than small ones. More explanation of the
shift-and-invert mode can be found in the SciPy document,
<a href="https://docs.scipy.org/doc/scipy/tutorial/arpack.html">https://docs.scipy.org/doc/scipy/tutorial/arpack.html</a>.
</p>


<h3>Function Interface</h3>

<p>The matrix <i>A</i> can be specified through a function with
the definition
</p>
<pre>function(x, args)
{
    ## should return A %*% x
}</pre>
<p>which receives a vector <code>x</code> as an argument and returns a vector
of the same length. The function should have the effect of calculating
<i>A * x</i>, and extra arguments can be passed in through the
<code>args</code> parameter. In <code>eigs()</code>, user should also provide
the dimension of the implicit matrix through the argument <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Yixuan Qiu <a href="https://statr.me">https://statr.me</a>
</p>
<p>Jiali Mei <a href="mailto:vermouthmjl@gmail.com">vermouthmjl@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="../../base/help/eigen.html">eigen</a>()</code>, <code><a href="../../base/help/svd.html">svd</a>()</code>,
<code><a href="../help/svds.html">svds</a>()</code>
</p>


<h3>Examples</h3>

<pre>
library(Matrix)
n = 20
k = 5

## general matrices have complex eigenvalues
set.seed(111)
A1 = matrix(rnorm(n^2), n)  ## class "matrix"
A2 = Matrix(A1)             ## class "dgeMatrix"

eigs(A1, k)
eigs(A2, k, opts = list(retvec = FALSE))  ## eigenvalues only

## Sparse matrices
A1[sample(n^2, n^2 / 2)] = 0
A3 = as(A1, "dgCMatrix")
A4 = as(A1, "dgRMatrix")

eigs(A3, k)
eigs(A4, k)

## Function interface
f = function(x, args)
{
    as.numeric(args %*% x)
}
eigs(f, k, n = n, args = A3)

## Symmetric matrices have real eigenvalues
A5 = crossprod(A1)
eigs_sym(A5, k)

## Find the smallest (in absolute value) k eigenvalues of A5
eigs_sym(A5, k, which = "SM")

## Another way to do this: use the sigma argument
eigs_sym(A5, k, sigma = 0)

## The results should be the same,
## but the latter method is far more stable on large matrices
</pre>

<hr /><div style="text-align: center;">[Package <em>RSpectra</em> version 0.16-1 <a href="00Index.html">Index</a>]</div>
</div></body></html>
