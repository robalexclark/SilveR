<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: PLS-derived methods: one function to rule them all!</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for mixOmics {mixOmics}"><tr><td>mixOmics {mixOmics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>PLS-derived methods: one function to rule them all!</h2>

<h3>Description</h3>

<p><em>This is the documentation for mixOmics function from mixOmics package.
For package documentation refer to <code>help(package='mixOmics')</code></em>
</p>


<h3>Usage</h3>

<pre>
mixOmics(
  X,
  Y,
  indY,
  study,
  ncomp,
  keepX,
  keepY,
  design,
  tau = NULL,
  scheme,
  mode = c("regression", "canonical", "invariant", "classic"),
  scale,
  init,
  tol = 1e-06,
  max.iter = 100,
  near.zero.var = FALSE
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>Input data. Either a matrix or a list of data sets (called
'blocks') matching on the same samples. Data should be arranged in samples x
variables, with samples order matching in all data sets.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p>Outcome. Either a numeric matrix of responses or a factor or a
class vector for the discrete outcome.</p>
</td></tr>
<tr valign="top"><td><code>indY</code></td>
<td>
<p>To supply if Y is missing, indicates the position of the outcome
in the list X</p>
</td></tr>
<tr valign="top"><td><code>study</code></td>
<td>
<p>grouping factor indicating which samples are from the same
study</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>If <code>X</code> is a data matrix, <code>ncomp</code> is a single value.
If <code>X</code> is a list of data sets, <code>ncomp</code> is a numeric vector of
length the number of blocks in <code>X</code>. The number of components to include
in the model for each block (does not necessarily need to take the same
value for each block).</p>
</td></tr>
<tr valign="top"><td><code>keepX</code></td>
<td>
<p>Number of variables to keep in the <i>X</i>-loadings</p>
</td></tr>
<tr valign="top"><td><code>keepY</code></td>
<td>
<p>Number of variables to keep in the <i>Y</i>-loadings</p>
</td></tr>
<tr valign="top"><td><code>design</code></td>
<td>
<p>numeric matrix of size (number of blocks) x (number of blocks)
with only 0 or 1 values. A value of 1 (0) indicates a relationship (no
relationship) between the blocks to be modelled. If <code>Y</code> is provided
instead of <code>indY</code>, the <code>design</code> matrix is changed to include
relationships to <code>Y</code>.</p>
</td></tr>
<tr valign="top"><td><code>tau</code></td>
<td>
<p>numeric vector of length the number of blocks in <code>X</code>. Each
regularization parameter will be applied on each block and takes the value
between 0 (no regularisation) and 1. If tau = &quot;optimal&quot; the shrinkage
paramaters are estimated for each block and each dimension using the Schafer
and Strimmer (2005) analytical formula.</p>
</td></tr>
<tr valign="top"><td><code>scheme</code></td>
<td>
<p>Either &quot;horst&quot;, &quot;factorial&quot; or &quot;centroid&quot; (Default:
&quot;centroid&quot;), see reference paper.</p>
</td></tr>
<tr valign="top"><td><code>mode</code></td>
<td>
<p>character string. What type of algorithm to use, (partially)
matching one of <code>"regression"</code>, <code>"canonical"</code>, <code>"invariant"</code>
or <code>"classic"</code>. See Details.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>Logical. If scale = TRUE, each block is standardized to zero
means and unit variances (default: TRUE)</p>
</td></tr>
<tr valign="top"><td><code>init</code></td>
<td>
<p>Mode of initialization use in the algorithm, either by Singular
Value Decompostion of the product of each block of X with Y (&quot;svd&quot;) or each
block independently (&quot;svd.single&quot;) . Default to &quot;svd&quot;.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>Convergence stopping value.</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>integer, the maximum number of iterations.</p>
</td></tr>
<tr valign="top"><td><code>near.zero.var</code></td>
<td>
<p>Logical, see the internal <code><a href="../../mixOmics/help/nearZeroVar.html">nearZeroVar</a></code>
function (should be set to TRUE in particular for data with many zero
values). Setting this argument to FALSE (when appropriate) will speed up the
computations. Default value is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs one of the PLS derived methods included in the
mixOmics package that is the most appropriate for your input data, one of
(mint).(block).(s)pls(da) depending on your input data (single data, list of
data, discrete outcome, ...)
</p>
<p>This function performs one of the PLS derived methods included in the
mixOmics package that is the most appropriate for your input data, one of
(mint).(block).(s)pls(da).
</p>
<p>If your input data <code>X</code> is a matrix, then the algorithm is directed
towards one of (mint).(s)pls(da) depending on your input data <code>Y</code>
(factor for the discrete outcome directs the algorithm to DA analysis) and
whether you input a <code>study</code> parameter (MINT analysis) or a <code>keepX</code>
parameter (sparse analysis).
</p>
<p>If your input data <code>X</code> is a list of matrices, then the algorithm is
directed towards one of (mint).block.(s)pls(da) depending on your input data
<code>Y</code> (factor for the discrete outcome directs the algorithm to DA
analysis) and whether you input a <code>study</code> parameter (MINT analysis) or
a <code>keepX</code> parameter (sparse analysis).
</p>
<p>More details about the PLS modes in <code>?pls</code>.
</p>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>Florian Rohart, Kim-Anh Lê Cao, Al J Abadi
</p>


<h3>References</h3>

<p>mixOmics article:
</p>
<p>Rohart F, Gautier B, Singh A, Lê Cao K-A. mixOmics: an R package for 'omics
feature selection and multiple data integration. PLoS Comput Biol 13(11):
e1005752
</p>
<p>MINT models:
</p>
<p>Rohart F, Eslami A, Matigian, N, Bougeard S, Lê Cao K-A (2017). MINT: A
multivariate integrative approach to identify a reproducible biomarker
signature across multiple experiments and platforms. BMC Bioinformatics
18:128.
</p>
<p>Eslami, A., Qannari, E. M., Kohler, A., and Bougeard, S. (2013). Multi-group
PLS Regression: Application to Epidemiology. In New Perspectives in Partial
Least Squares and Related Methods, pages 243-255. Springer.
</p>
<p>Integration of omics data sets:
</p>
<p>Singh A, Gautier B, Shannon C, Vacher M, Rohart F, Tebbutt S, Lê Cao K-A.
DIABLO: an integrative, multi-omics, multivariate method for multi-group
classification. <a href="http://biorxiv.org/content/early/2016/08/03/067611">http://biorxiv.org/content/early/2016/08/03/067611</a>
</p>
<p>Lê Cao, K.-A., Martin, P.G.P., Robert-Granie, C. and Besse, P. (2009).
Sparse canonical methods for biological data integration: application to a
cross-platform study. <em>BMC Bioinformatics</em> <b>10</b>:34.
</p>
<p>Lê Cao, K.-A., Rossouw, D., Robert-Granie, C. and Besse, P. (2008). A sparse
PLS for variable selection when integrating Omics data. <em>Statistical
Applications in Genetics and Molecular Biology</em> <b>7</b>, article 35.
</p>
<p>Tenenhaus A., Phillipe C., Guillemot V., Lê Cao K-A. , Grill J. , Frouin V.
(2014), Variable selection for generalized canonical correlation analysis,
<em>Biostatistics</em>, doi: 10.1093/biostatistics. PMID: 24550197.
</p>
<p>Sparse SVD:
</p>
<p>Shen, H. and Huang, J. Z. (2008). Sparse principal component analysis via
regularized low rank matrix approximation. <em>Journal of Multivariate
Analysis</em> <b>99</b>, 1015-1034.
</p>
<p>PLS-DA:
</p>
<p>Lê Cao K-A, Boitard S and Besse P (2011). Sparse PLS Discriminant Analysis:
biologically relevant feature selection and graphical displays for
multiclass problems. BMC Bioinformatics 12:253.
</p>
<p>PLS:
</p>
<p>Tenenhaus, M. (1998). <em>La regression PLS: theorie et pratique</em>. Paris:
Editions Technic.
</p>
<p>Wold H. (1966). Estimation of principal components and related models by
iterative least squares. In: Krishnaiah, P. R. (editors), <em>Multivariate
Analysis</em>. Academic Press, N.Y., 391-420.
</p>
<p>Abdi H (2010). Partial least squares regression and projection on latent
structure regression (PLS Regression). <em>Wiley Interdisciplinary
Reviews: Computational Statistics</em>, 2(1), 97-106.
</p>
<p>On multilevel analysis:
</p>
<p>Liquet, B., Lê Cao, K.-A., Hocini, H. and Thiebaut, R. (2012) A novel
approach for biomarker selection and the integration of repeated measures
experiments from two platforms. <em>BMC Bioinformatics</em> <b>13</b>:325.
</p>
<p>Westerhuis, J. A., van Velzen, E. J., Hoefsloot, H. C., and Smilde, A. K.
(2010). Multivariate paired data analysis: multilevel PLSDA versus OPLSDA.
<em>Metabolomics</em>, <b>6</b>(1), 119-128.
</p>
<p>Visualisations:
</p>
<p>González I., Lê Cao K.-A., Davis, M.D. and Déjean S. (2013) Insightful
graphical outputs to explore relationships between two omics data sets.
BioData Mining 5:19.
</p>


<h3>See Also</h3>

<p><code><a href="../../mixOmics/help/pls.html">pls</a></code>, <code><a href="../../mixOmics/help/spls.html">spls</a></code>, <code><a href="../../mixOmics/help/plsda.html">plsda</a></code>,
<code><a href="../../mixOmics/help/splsda.html">splsda</a></code>, <code><a href="../../mixOmics/help/mint.pls.html">mint.pls</a></code>, <code><a href="../../mixOmics/help/mint.spls.html">mint.spls</a></code>,
<code><a href="../../mixOmics/help/mint.plsda.html">mint.plsda</a></code>, <code><a href="../../mixOmics/help/mint.splsda.html">mint.splsda</a></code>,
<code><a href="../../mixOmics/help/block.pls.html">block.pls</a></code>, <code><a href="../../mixOmics/help/block.spls.html">block.spls</a></code>,
<code><a href="../../mixOmics/help/block.plsda.html">block.plsda</a></code>, <code><a href="../../mixOmics/help/block.splsda.html">block.splsda</a></code>,
<code><a href="../../mixOmics/help/mint.block.pls.html">mint.block.pls</a></code>, <code><a href="../../mixOmics/help/mint.block.spls.html">mint.block.spls</a></code>,
<code><a href="../../mixOmics/help/mint.block.plsda.html">mint.block.plsda</a></code>, <code><a href="../../mixOmics/help/mint.block.splsda.html">mint.block.splsda</a></code>
</p>


<h3>Examples</h3>

<pre>
## -- directed towards PLS framework because X is a matrix and the study argument is missing
# ----------------------------------------------------
data(liver.toxicity)
X = liver.toxicity$gene
Y = liver.toxicity$clinic
Y.factor = as.factor(liver.toxicity$treatment[, 4])

# directed towards PLS
out = mixOmics(X, Y, ncomp = 2)

# directed towards sPLS because of keepX and/or keepY
out = mixOmics(X, Y, ncomp = 2, keepX = c(50, 50), keepY = c(10, 10))

# directed towards PLS-DA because Y is a factor
out = mixOmics(X, Y.factor, ncomp = 2)

# directed towards sPLS-DA because Y is a factor and there is a keepX
out = mixOmics(X, Y.factor, ncomp = 2, keepX = c(20, 20))


## Not run: 
## -- directed towards block.pls framework because X is a list
# ----------------------------------------------------
data(nutrimouse)
Y = unmap(nutrimouse$diet)
data = list(gene = nutrimouse$gene, lipid = nutrimouse$lipid, Y = Y)

# directed towards block PLS
out = mixOmics(X = data, Y = Y,ncomp = 3)

# directed towards block sPLS because of keepX and/or keepY
out = mixOmics(X = data, Y = Y,ncomp = 3,
keepX = list(gene = c(10,10), lipid = c(15,15)))

# directed towards block PLS-DA because Y is a factor
out = mixOmics(X = data, Y = nutrimouse$diet, ncomp = 3)

# directed towards block sPLS-DA because Y is a factor and there is a keepX
out = mixOmics(X = data, Y = nutrimouse$diet, ncomp = 3,
keepX = list(gene = c(10,10), lipid = c(15,15)))


## -- directed towards mint.pls framework because of the study factor
# ----------------------------------------------------
data(stemcells)
# directed towards PLS
out = mixOmics(X = stemcells$gene, Y = unmap(stemcells$celltype), ncomp = 2)

# directed towards mint.PLS
out = mixOmics(X = stemcells$gene, Y = unmap(stemcells$celltype),
ncomp = 2, study = stemcells$study)

# directed towards mint.sPLS because of keepX and/or keepY
out = mixOmics(X = stemcells$gene, Y = unmap(stemcells$celltype),
ncomp = 2, study = stemcells$study, keepX = c(10, 5, 15))

# directed towards mint.PLS-DA because Y is a factor
out = mixOmics(X = stemcells$gene, Y = stemcells$celltype, ncomp = 2,
study = stemcells$study)

# directed towards mint.sPLS-DA because Y is a factor and there is a keepX
out = mixOmics(X = stemcells$gene, Y = stemcells$celltype, ncomp = 2,
study = stemcells$study, keepX = c(10, 5, 15))

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>mixOmics</em> version 6.18.1 <a href="00Index.html">Index</a>]</div>
</div></body></html>
