<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: PLS-derived methods: one function to rule them all!</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for mixOmics {mixOmics}"><tr><td>mixOmics {mixOmics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>PLS-derived methods: one function to rule them all!</h2>

<h3>Description</h3>

<p>This function performs one of the PLS derived methods included in the mixOmics package that is the most appropriate for your input data, one of (mint).(block).(s)pls(da) depending on your input data (single data, list of data, discrete outcome, ...)
</p>


<h3>Usage</h3>

<pre>
mixOmics(X,
Y,
indY,
study,
ncomp,
keepX,
keepY,
design,
tau = NULL,# rgcca, number between 0,1 or "optimal"
scheme,
mode,
scale,
init,
tol =  1e-06,
max.iter = 100,
near.zero.var = FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>Input data. Either a matrix or a list of data sets (called 'blocks') matching on the same samples. Data should be arranged in samples x variables, with samples order matching in all data sets.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p>Outcome. Either a numeric matrix of responses or a factor or a class vector for the discrete outcome.</p>
</td></tr>
<tr valign="top"><td><code>indY</code></td>
<td>
<p>To supply if Y is missing, indicates the position of the outcome in the list X</p>
</td></tr>
<tr valign="top"><td><code>study</code></td>
<td>
<p>grouping factor indicating which samples are from the same study</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>If <code>X</code> is a data matrix, <code>ncomp</code> is a single value. If <code>X</code> is a list of data sets, <code>ncomp</code> is a numeric vector of length the number of blocks in <code>X</code>. The number of components to include in the model for each block (does not necessarily need to take the same value for each block).</p>
</td></tr>
<tr valign="top"><td><code>keepX</code></td>
<td>
<p>Number of variables to keep in the <i>X</i>-loadings</p>
</td></tr>
<tr valign="top"><td><code>keepY</code></td>
<td>
<p>Number of variables to keep in the <i>Y</i>-loadings</p>
</td></tr>
<tr valign="top"><td><code>design</code></td>
<td>
<p>numeric matrix of size (number of blocks) x (number of blocks) with only 0 or 1 values. A value of 1 (0) indicates a relationship (no relationship) between the blocks to be modelled. If <code>Y</code> is provided instead of <code>indY</code>, the <code>design</code> matrix is changed to include relationships to <code>Y</code>. </p>
</td></tr>
<tr valign="top"><td><code>tau</code></td>
<td>
<p>numeric vector of length the number of blocks in <code>X</code>. Each regularization parameter will be applied on each block and takes the value between 0 (no regularisation) and 1. If tau = &quot;optimal&quot; the shrinkage paramaters are estimated for each block and
each dimension using the Schafer and Strimmer (2005)
analytical formula.</p>
</td></tr>
<tr valign="top"><td><code>scheme</code></td>
<td>
<p>Either &quot;horst&quot;, &quot;factorial&quot; or &quot;centroid&quot; (Default: &quot;centroid&quot;), see reference paper.</p>
</td></tr>
<tr valign="top"><td><code>mode</code></td>
<td>
<p>character string. What type of algorithm to use, (partially) matching
one of <code>"regression"</code>, <code>"canonical"</code>, <code>"invariant"</code> or <code>"classic"</code>.
See Details.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>boleean. If scale = TRUE, each block is standardized
to zero means and unit variances (default: TRUE)</p>
</td></tr>
<tr valign="top"><td><code>init</code></td>
<td>
<p>Mode of initialization use in the algorithm, either by Singular Value Decompostion of the product of each block of X with Y (&quot;svd&quot;) or each block independently (&quot;svd.single&quot;) . Default to &quot;svd&quot;.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>Convergence stopping value.</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>integer, the maximum number of iterations.</p>
</td></tr>
<tr valign="top"><td><code>near.zero.var</code></td>
<td>
<p>boolean, see the internal <code><a href="nearZeroVar.html">nearZeroVar</a></code> function (should be set to TRUE in particular for data with many zero values). Setting this argument to FALSE (when appropriate) will speed up the computations. Default value is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs one of the PLS derived methods included in the mixOmics package that is the most appropriate for your input data, one of (mint).(block).(s)pls(da).
</p>
<p>If your input data <code>X</code> is a matrix, then the algorithm is directed towards one of (mint).(s)pls(da) depending on your input data <code>Y</code> (factor for the discrete outcome directs the algorithm to DA analysis) and whether you input a <code>study</code> parameter (MINT analysis) or a <code>keepX</code> parameter (sparse analysis).
</p>
<p>If your input data <code>X</code> is a list of matrices, then the algorithm is directed towards one of (mint).block.(s)pls(da) depending on your input data <code>Y</code> (factor for the discrete outcome directs the algorithm to DA analysis) and whether you input a <code>study</code> parameter (MINT analysis) or a <code>keepX</code> parameter (sparse analysis).
</p>
<p>More details about the PLS modes in <code>?pls</code>.
</p>


<h3>Value</h3>

<p>none</p>


<h3>Author(s)</h3>

<p>Florian Rohart</p>


<h3>References</h3>

<p>mixOmics article:
</p>
<p>Rohart F, Gautier B, Singh A, Lê Cao K-A. mixOmics: an R package for 'omics feature selection and multiple data integration. PLoS Comput Biol 13(11): e1005752
</p>
<p>MINT models:
</p>
<p>Rohart F, Eslami A, Matigian, N, Bougeard S, Lê Cao K-A (2017). MINT: A multivariate integrative approach to identify a reproducible biomarker signature across multiple experiments and platforms. BMC Bioinformatics 18:128.
</p>
<p>Eslami, A., Qannari, E. M., Kohler, A., and Bougeard, S. (2013). Multi-group PLS Regression: Application to Epidemiology. In New Perspectives in Partial Least Squares and Related Methods, pages 243-255. Springer.
</p>
<p>Integration of omics data sets:
</p>
<p>Singh A, Gautier B, Shannon C, Vacher M, Rohart F, Tebbutt S, Lê Cao K-A. DIABLO: an integrative, multi-omics, multivariate method for multi-group classification. <a href="http://biorxiv.org/content/early/2016/08/03/067611">http://biorxiv.org/content/early/2016/08/03/067611</a>
</p>
<p>Lê Cao, K.-A., Martin, P.G.P., Robert-Granie, C. and Besse, P. (2009). Sparse canonical methods
for biological data integration: application to a cross-platform study. <em>BMC Bioinformatics</em> <b>10</b>:34.
</p>
<p>Lê Cao, K.-A., Rossouw, D., Robert-Granie, C. and Besse, P. (2008). A sparse PLS for variable
selection when integrating Omics data. <em>Statistical Applications in Genetics and Molecular
Biology</em> <b>7</b>, article 35.
</p>
<p>Tenenhaus A., Phillipe C., Guillemot V., Lê Cao K-A. , Grill J. , Frouin V.  (2014), Variable selection for generalized canonical correlation analysis, <em>Biostatistics</em>, doi: 10.1093/biostatistics. PMID: 24550197.
</p>
<p>Sparse SVD:
</p>
<p>Shen, H. and Huang, J. Z. (2008). Sparse principal component analysis via regularized
low rank matrix approximation. <em>Journal of Multivariate Analysis</em> <b>99</b>, 1015-1034.
</p>
<p>PLS-DA:
</p>
<p>Lê Cao K-A, Boitard S and Besse P (2011). Sparse PLS Discriminant Analysis: biologically relevant feature selection and graphical displays for multiclass problems. BMC Bioinformatics 12:253.
</p>
<p>PLS:
</p>
<p>Tenenhaus, M. (1998). <em>La regression PLS: theorie et pratique</em>. Paris: Editions Technic.
</p>
<p>Wold H. (1966). Estimation of principal components and related models by iterative least squares. In: Krishnaiah, P. R. (editors), <em>Multivariate Analysis</em>. Academic Press, N.Y., 391-420.
</p>
<p>Abdi H (2010). Partial least squares regression and projection on latent structure regression (PLS Regression). <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2(1), 97-106.
</p>
<p>On multilevel analysis:
</p>
<p>Liquet, B., Lê Cao, K.-A., Hocini, H. and Thiebaut, R. (2012) A novel approach for
biomarker selection and the integration of repeated measures experiments from two
platforms. <em>BMC Bioinformatics</em> <b>13</b>:325.
</p>
<p>Westerhuis, J. A., van Velzen, E. J., Hoefsloot, H. C., and Smilde, A. K. (2010). Multivariate paired data analysis: multilevel PLSDA versus OPLSDA. <em>Metabolomics</em>,
<b>6</b>(1), 119-128.
</p>
<p>Visualisations:
</p>
<p>González I., Lê Cao K.-A., Davis, M.D. and Déjean S. (2013) Insightful graphical outputs to explore relationships between two omics data sets. BioData Mining 5:19.
</p>


<h3>See Also</h3>

<p><code><a href="pls.html">pls</a></code>, <code><a href="spls.html">spls</a></code>, <code><a href="plsda.html">plsda</a></code>, <code><a href="splsda.html">splsda</a></code>,
<code><a href="mint.pls.html">mint.pls</a></code>, <code><a href="mint.spls.html">mint.spls</a></code>, <code><a href="mint.plsda.html">mint.plsda</a></code>, <code><a href="mint.splsda.html">mint.splsda</a></code>,
<code><a href="block.pls.html">block.pls</a></code>, <code><a href="block.spls.html">block.spls</a></code>, <code><a href="block.plsda.html">block.plsda</a></code>, <code><a href="block.splsda.html">block.splsda</a></code>,
<code><a href="mint.block.pls.html">mint.block.pls</a></code>, <code><a href="mint.block.spls.html">mint.block.spls</a></code>, <code><a href="mint.block.plsda.html">mint.block.plsda</a></code>, <code><a href="mint.block.splsda.html">mint.block.splsda</a></code></p>


<h3>Examples</h3>

<pre>


## -- directed towards PLS framework because X is a matrix and the study argument is missing
# ----------------------------------------------------
data(liver.toxicity)
X = liver.toxicity$gene
Y = liver.toxicity$clinic
Y.factor = as.factor(liver.toxicity$treatment[, 4])

# directed towards PLS
out = mixOmics(X, Y, ncomp = 2)

# directed towards sPLS because of keepX and/or keepY
out = mixOmics(X, Y, ncomp = 2, keepX = c(50, 50), keepY = c(10, 10))

# directed towards PLS-DA because Y is a factor
out = mixOmics(X, Y.factor, ncomp = 2)

# directed towards sPLS-DA because Y is a factor and there is a keepX
out = mixOmics(X, Y.factor, ncomp = 2, keepX = c(20, 20))


## Not run: 
## -- directed towards block.pls framework because X is a list
# ----------------------------------------------------
data(nutrimouse)
Y = unmap(nutrimouse$diet)
data = list(gene = nutrimouse$gene, lipid = nutrimouse$lipid, Y = Y)

# directed towards block PLS
out = mixOmics(X = data, Y = Y,ncomp = 3)

# directed towards block sPLS because of keepX and/or keepY
out = mixOmics(X = data, Y = Y,ncomp = 3,
keepX = list(gene = c(10,10), lipid = c(15,15)))

# directed towards block PLS-DA because Y is a factor
out = mixOmics(X = data, Y = nutrimouse$diet, ncomp = 3)

# directed towards block sPLS-DA because Y is a factor and there is a keepX
out = mixOmics(X = data, Y = nutrimouse$diet, ncomp = 3,
keepX = list(gene = c(10,10), lipid = c(15,15)))


## -- directed towards mint.pls framework because of the study factor
# ----------------------------------------------------
data(stemcells)
# directed towards PLS
out = mixOmics(X = stemcells$gene, Y = unmap(stemcells$celltype), ncomp = 2)

# directed towards mint.PLS
out = mixOmics(X = stemcells$gene, Y = unmap(stemcells$celltype),
ncomp = 2, study = stemcells$study)

# directed towards mint.sPLS because of keepX and/or keepY
out = mixOmics(X = stemcells$gene, Y = unmap(stemcells$celltype),
ncomp = 2, study = stemcells$study, keepX = c(10, 5, 15))

# directed towards mint.PLS-DA because Y is a factor
out = mixOmics(X = stemcells$gene, Y = stemcells$celltype, ncomp = 2,
study = stemcells$study)

# directed towards mint.sPLS-DA because Y is a factor and there is a keepX
out = mixOmics(X = stemcells$gene, Y = stemcells$celltype, ncomp = 2,
study = stemcells$study, keepX = c(10, 5, 15))

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>mixOmics</em> version 6.6.2 <a href="00Index.html">Index</a>]</div>
</body></html>
