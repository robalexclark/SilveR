<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Partial Least Squares (PLS) Regression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for pls {mixOmics}"><tr><td>pls {mixOmics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Partial Least Squares (PLS) Regression</h2>

<h3>Description</h3>

<p>Function to perform Partial Least Squares (PLS) regression.
</p>


<h3>Usage</h3>

<pre>
pls(
  X,
  Y,
  ncomp = 2,
  scale = TRUE,
  mode = c("regression", "canonical", "invariant", "classic"),
  tol = 1e-06,
  max.iter = 100,
  near.zero.var = FALSE,
  logratio = "none",
  multilevel = NULL,
  all.outputs = TRUE
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>numeric matrix of predictors with the rows as individual
observations. missing values (<code>NA</code>s) are allowed.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p>numeric matrix of response(s) with the rows as individual
observations matching <code>X</code>. missing values (<code>NA</code>s) are allowed.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>Positive Integer. The number of components to include in the
model. Default to 2.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>Logical. If scale = TRUE, each block is standardized to zero
means and unit variances (default: TRUE)</p>
</td></tr>
<tr valign="top"><td><code>mode</code></td>
<td>
<p>Character string indicating the type of PLS algorithm to use. One
of <code>"regression"</code>, <code>"canonical"</code>, <code>"invariant"</code> or <code>"classic"</code>. See Details.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>Positive numeric used as convergence criteria/tolerance during the
iterative process. Default to <code>1e-06</code>.</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>Integer, the maximum number of iterations. Default to  100.</p>
</td></tr>
<tr valign="top"><td><code>near.zero.var</code></td>
<td>
<p>Logical, see the internal <code><a href="../../mixOmics/help/nearZeroVar.html">nearZeroVar</a></code>
function (should be set to TRUE in particular for data with many zero
values). Setting this argument to FALSE (when appropriate) will speed up the
computations. Default value is FALSE.</p>
</td></tr>
<tr valign="top"><td><code>logratio</code></td>
<td>
<p>Character, one of ('none','CLR') specifies
the log ratio transformation to deal with compositional values that may
arise from specific normalisation in sequencing data. Default to 'none'.
See <code>?logratio.transfo</code> for details.</p>
</td></tr>
<tr valign="top"><td><code>multilevel</code></td>
<td>
<p>Numeric, design matrix for repeated measurement analysis,
where multilevel decomposition is required. For a one factor decomposition,
the repeated measures on each individual, i.e. the individuals ID is input
as the first column. For a 2 level factor decomposition then 2nd AND 3rd
columns indicate those factors. See examplesin <code>?spls</code>.</p>
</td></tr>
<tr valign="top"><td><code>all.outputs</code></td>
<td>
<p>Logical. Computation can be faster when some specific
(and non-essential) outputs are not calculated. Default = <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pls</code> function fit PLS models with <i>1, &hellip; ,</i><code>ncomp</code>
components. Multi-response models are fully supported. The <code>X</code> and
<code>Y</code> datasets can contain missing values.
</p>
<p>The type of algorithm to use is specified with the <code>mode</code> argument.
Four PLS algorithms are available: PLS regression <code>("regression")</code>, PLS
canonical analysis <code>("canonical")</code>, redundancy analysis
<code>("invariant")</code> and the classical PLS algorithm <code>("classic")</code> (see
References). Different modes relate on how the Y matrix is deflated across
the iterations of the algorithms - i.e. the different components.
</p>
<p>- Regression mode: the Y matrix is deflated with respect to the information
extracted/modelled from the local regression on X. Here the goal is to
predict Y from X (Y and X play an asymmetric role). Consequently the latent
variables computed to predict Y from X are different from those computed to
predict X from Y.
</p>
<p>- Canonical mode: the Y matrix is deflated to the information
extracted/modelled from the local regression on Y. Here X and Y play a
symmetric role and the goal is similar to a Canonical Correlation type of
analysis.
</p>
<p>- Invariant mode: the Y matrix is not deflated
</p>
<p>- Classic mode: is similar to a regression mode. It gives identical results
for the variates and loadings associated to the X data set, but differences
for the loadings vectors associated to the Y data set (different
normalisations are used). Classic mode is the PLS2 model as defined by
Tenenhaus (1998), Chap 9.
</p>
<p>Note that in all cases the results are the same on the first component as
deflation only starts after component 1.
</p>


<h3>Value</h3>

<p><code>pls</code> returns an object of class <code>"pls"</code>, a list that
contains the following components:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>the centered and standardized original predictor matrix.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p>the centered and standardized original response vector or matrix.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>the number of components included in the model.</p>
</td></tr>
<tr valign="top"><td><code>mode</code></td>
<td>
<p>the algorithm used to fit the model.</p>
</td></tr> <tr valign="top"><td><code>variates</code></td>
<td>
<p>list
containing the variates.</p>
</td></tr> <tr valign="top"><td><code>loadings</code></td>
<td>
<p>list containing the estimated
loadings for the <i>X</i> and <i>Y</i> variates. The loading weights multiplied with their associated deflated (residual) matrix gives the variate.</p>
</td></tr> <tr valign="top"><td><code>loadings.stars</code></td>
<td>
<p>list containing the estimated
weighted loadings for the <i>X</i> and <i>Y</i> variates. The loading weights are projected so that when multiplied with their associated original matrix we obtain the variate.</p>
</td></tr> <tr valign="top"><td><code>names</code></td>
<td>
<p>list containing
the names to be used for individuals and variables.</p>
</td></tr> <tr valign="top"><td><code>tol</code></td>
<td>
<p>the
tolerance used in the iterative algorithm, used for subsequent S3 methods</p>
</td></tr>
<tr valign="top"><td><code>iter</code></td>
<td>
<p>Number of iterations of the algorithm for each component</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>the maximum number of iterations, used for subsequent S3
methods</p>
</td></tr> <tr valign="top"><td><code>nzv</code></td>
<td>
<p>list containing the zero- or near-zero predictors
information.</p>
</td></tr> <tr valign="top"><td><code>scale</code></td>
<td>
<p>whether scaling was applied per predictor.</p>
</td></tr>
<tr valign="top"><td><code>logratio</code></td>
<td>
<p>whether log ratio transformation for relative proportion
data was applied, and if so, which type of transformation.</p>
</td></tr>
<tr valign="top"><td><code>prop_expl_var</code></td>
<td>
<p>The proportion of the variance explained by each
variate / component divided by the total variance in the <code>data</code> (after
removing the possible missing values) using the definition of 'redundancy'.
Note that contrary to <code>PCA</code>, this amount may not decrease in the
following components as the aim of the method is not to maximise the
variance, but the covariance between data sets (including the dummy matrix
representation of the outcome variable in case of the supervised
approaches).</p>
</td></tr>
<tr valign="top"><td><code>input.X</code></td>
<td>
<p>numeric matrix of predictors in X that was input, before any
scaling / logratio / multilevel transformation.</p>
</td></tr> <tr valign="top"><td><code>mat.c</code></td>
<td>
<p>matrix of
coefficients from the regression of X / residual matrices X on the
X-variates, to be used internally by <code>predict</code>.</p>
</td></tr>
<tr valign="top"><td><code>defl.matrix</code></td>
<td>
<p>residual matrices X for each dimension.</p>
</td></tr>
</table>


<h3>missing values</h3>

<p>The estimation of the missing values can be performed using the
<code><a href="../../mixOmics/help/impute.nipals.html">impute.nipals</a></code> function. Otherwise, missing values are handled
by element-wise deletion in the <code>pls</code> function without having to delete
the rows with missing data.
</p>


<h3>multilevel</h3>

<p>Multilevel (s)PLS enables the integration of data measured on two different
data sets on the same individuals. This approach differs from multilevel
sPLS-DA as the aim is to select subsets of variables from both data sets that
are highly positively or negatively correlated across samples. The approach
is unsupervised, i.e. no prior knowledge about the sample groups is included.
</p>


<h3>logratio and multilevel</h3>

<p>logratio transform and multilevel analysis are performed sequentially as
internal pre-processing step, through <code><a href="../../mixOmics/help/logratio.transfo.html">logratio.transfo</a></code> and
<code><a href="../../mixOmics/help/withinVariation.html">withinVariation</a></code> respectively.
</p>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González, Florian Rohart, Kim-Anh Lê Cao,
Al J Abadi
</p>


<h3>References</h3>

<p>Tenenhaus, M. (1998). <em>La regression PLS: theorie et
pratique</em>. Paris: Editions Technic.
</p>
<p>Wold H. (1966). Estimation of principal components and related models by
iterative least squares. In: Krishnaiah, P. R. (editors), <em>Multivariate
Analysis</em>. Academic Press, N.Y., 391-420.
</p>
<p>Abdi H (2010). Partial least squares regression and projection on latent
structure regression (PLS Regression). <em>Wiley Interdisciplinary
Reviews: Computational Statistics</em>, 2(1), 97-106.
</p>


<h3>See Also</h3>

<p><code><a href="../../mixOmics/help/spls.html">spls</a></code>, <code><a href="../../mixOmics/help/summary.html">summary</a></code>, <code><a href="../../mixOmics/help/plotIndiv.html">plotIndiv</a></code>,
<code><a href="../../mixOmics/help/plotVar.html">plotVar</a></code>, <code><a href="../../mixOmics/help/predict.html">predict</a></code>, <code><a href="../../mixOmics/help/perf.html">perf</a></code> and
http://www.mixOmics.org for more details.
</p>


<h3>Examples</h3>

<pre>
data(linnerud)
X &lt;- linnerud$exercise
Y &lt;- linnerud$physiological
linn.pls &lt;- pls(X, Y, mode = "classic")

## Not run: 
data(liver.toxicity)
X &lt;- liver.toxicity$gene
Y &lt;- liver.toxicity$clinic
toxicity.pls &lt;- pls(X, Y, ncomp = 3)

## End(Not run)

</pre>

<hr /><div style="text-align: center;">[Package <em>mixOmics</em> version 6.18.1 <a href="00Index.html">Index</a>]</div>
</div></body></html>
