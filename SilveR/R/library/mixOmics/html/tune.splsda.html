<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Tuning functions for sPLS-DA method</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for tune.splsda {mixOmics}"><tr><td>tune.splsda {mixOmics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Tuning functions for sPLS-DA method</h2>

<h3>Description</h3>

<p>Computes M-fold or Leave-One-Out Cross-Validation scores on a user-input
grid to determine optimal values for the sparsity parameters in <code>splsda</code>.
</p>


<h3>Usage</h3>

<pre>
tune.splsda(X, Y, ncomp = 1,
test.keepX = c(5, 10, 15), already.tested.X, validation = "Mfold",
folds = 10, dist = "max.dist", measure = "BER", scale = TRUE, auc = FALSE,
progressBar = TRUE, tol = 1e-06,max.iter = 100, near.zero.var = FALSE,
nrepeat = 1, logratio = c('none','CLR'), multilevel = NULL, light.output = TRUE, cpus)

</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>numeric matrix of predictors. <code>NA</code>s are allowed.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p><code>if(method = 'spls')</code> numeric vector or matrix of continuous responses (for multi-response models) <code>NA</code>s are allowed.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>the number of components to include in the model.</p>
</td></tr>
<tr valign="top"><td><code>test.keepX</code></td>
<td>
<p>numeric vector for the different number of variables to test from the <i>X</i> data set</p>
</td></tr>
<tr valign="top"><td><code>already.tested.X</code></td>
<td>
<p>Optional, if <code>ncomp &gt; 1</code> A numeric vector indicating the number of variables to select from the <i>X</i> data set on the firsts components.</p>
</td></tr>
<tr valign="top"><td><code>validation</code></td>
<td>
<p>character.  What kind of (internal) validation to use, matching one of <code>"Mfold"</code> or
<code>"loo"</code> (see below). Default is <code>"Mfold"</code>.</p>
</td></tr>
<tr valign="top"><td><code>folds</code></td>
<td>
<p>the folds in the Mfold cross-validation. See Details.</p>
</td></tr>
<tr valign="top"><td><code>dist</code></td>
<td>
<p>distance metric to use for <code>splsda</code> to estimate the classification error rate,
should be a subset of <code>"centroids.dist"</code>, <code>"mahalanobis.dist"</code> or <code>"max.dist"</code> (see Details).</p>
</td></tr>
<tr valign="top"><td><code>measure</code></td>
<td>
<p>Two misclassification measure are available: overall misclassification error <code>overall</code> or the Balanced Error Rate <code>BER</code></p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>boleean. If scale = TRUE, each block is standardized
to zero means and unit variances (default: TRUE)</p>
</td></tr>
<tr valign="top"><td><code>auc</code></td>
<td>
<p>if <code>TRUE</code> calculate the Area Under the Curve (AUC) performance of the model.</p>
</td></tr>
<tr valign="top"><td><code>progressBar</code></td>
<td>
<p>by default set to <code>TRUE</code> to output the progress bar of the computation.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>Convergence stopping value.</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>integer, the maximum number of iterations.</p>
</td></tr>
<tr valign="top"><td><code>near.zero.var</code></td>
<td>
<p>boolean, see the internal <code><a href="nearZeroVar.html">nearZeroVar</a></code> function (should be set to TRUE in particular for data with many zero values). Default value is FALSE</p>
</td></tr>
<tr valign="top"><td><code>nrepeat</code></td>
<td>
<p>Number of times the Cross-Validation process is repeated.</p>
</td></tr>
<tr valign="top"><td><code>logratio</code></td>
<td>
<p>one of ('none','CLR'). Default to 'none'</p>
</td></tr>
<tr valign="top"><td><code>multilevel</code></td>
<td>
<p>Design matrix for multilevel analysis (for repeated measurements) that indicates the repeated measures on each individual, i.e. the individuals ID. See Details.</p>
</td></tr>
<tr valign="top"><td><code>light.output</code></td>
<td>
<p>if set to FALSE, the prediction/classification of each sample for each of <code>test.keepX</code> and each comp is returned.</p>
</td></tr>
<tr valign="top"><td><code>cpus</code></td>
<td>
<p>Number of cpus to use when running the code in parallel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This tuning function should be used to tune the parameters in the <code>splsda</code> function (number of components and number of variables in <code>keepX</code> to select).
</p>
<p>For a sPLS-DA, M-fold or LOO cross-validation is performed with stratified subsampling where all classes are represented in each fold.
</p>
<p>If <code>validation = "loo"</code>, leave-one-out cross-validation is performed. By default <code>folds</code> is set to the number of unique individuals.
</p>
<p>The function outputs the optimal number of components that achieve the best performance based on the overall error rate or BER. The assessment is data-driven and similar to the process detailed in (Rohart et al., 2016), where one-sided t-tests assess whether there is a gain in performance when adding a component to the model. Our experience has shown that in most case, the optimal number of components is the number of categories in <code>Y</code> - 1, but it is worth tuning a few extra components to check (see our website and case studies for more details).
</p>
<p>For sPLS-DA multilevel one-factor analysis, M-fold or LOO cross-validation is performed where all repeated measurements of one sample are in the same fold. Note that logratio transform and the multilevel analysis are performed internally and independently on the training and test set.
</p>
<p>For a sPLS-DA multilevel two-factor analysis, the correlation between components from the within-subject variation of X and the <code>cond</code> matrix is computed on the whole data set. The reason why we cannot obtain a cross-validation error rate as for the spls-DA one-factor analysis is because of the dififculty to decompose and predict the within matrices within each fold.
</p>
<p>For a sPLS two-factor analysis a sPLS canonical mode is run, and the correlation between components from the within-subject variation of X and Y is computed on the whole data set.
</p>
<p>If <code>validation = "Mfold"</code>, M-fold cross-validation is performed.
How many folds to generate is selected by specifying the number of folds in <code>folds</code>.
</p>
<p>If <code>auc = TRUE</code> and there are more than 2 categories in <code>Y</code>, the Area Under the Curve is averaged using one-vs-all comparison. Note however that the AUC criteria may not be particularly insightful as the prediction threshold we use in sPLS-DA differs from an AUC threshold (sPLS-DA relies on prediction distances for predictions, see <code>?predict.splsda</code> for more details) and the supplemental material of the mixOmics article (Rohart et al. 2017).
</p>
<p>BER is appropriate in case of an unbalanced number of samples per class as it calculates the average proportion of wrongly classified samples in each class, weighted by the number of samples in each class. BER is less biased towards majority classes during the performance assessment.
</p>
<p>More details about the prediction distances in <code>?predict</code> and the supplemental material of the mixOmics article (Rohart et al. 2017).
</p>


<h3>Value</h3>

<p>Depending on the type of analysis performed, a list that contains:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>error.rate</code></td>
<td>
<p>returns the prediction error for each <code>test.keepX</code> on each component, averaged across all repeats and subsampling folds. Standard deviation is also output. All error rates are also available as a list.</p>
</td></tr>
<tr valign="top"><td><code>choice.keepX</code></td>
<td>
<p>returns the number of variables selected (optimal keepX) on each component.</p>
</td></tr>
<tr valign="top"><td><code>choice.ncomp</code></td>
<td>
<p>returns the optimal number of components for the model fitted with <code>$choice.keepX</code> </p>
</td></tr>
<tr valign="top"><td><code>error.rate.class</code></td>
<td>
<p>returns the error rate for each level of <code>Y</code> and for each component computed with the optimal keepX</p>
</td></tr>
<tr valign="top"><td><code>predict</code></td>
<td>
<p>Prediction values for each sample, each <code>test.keepX</code>, each comp and each repeat. Only if light.output=FALSE</p>
</td></tr>
<tr valign="top"><td><code>class</code></td>
<td>
<p>Predicted class for each sample, each <code>test.keepX</code>, each comp and each repeat. Only if light.output=FALSE</p>
</td></tr>
<tr valign="top"><td><code>auc</code></td>
<td>
<p>AUC mean and standard deviation if the number of categories in <code>Y</code> is greater than 2, see details above. Only if auc = TRUE</p>
</td></tr>
<tr valign="top"><td><code>cor.value</code></td>
<td>
<p>only if multilevel analysis with 2 factors: correlation between latent variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kim-Anh Lê Cao, Benoit Gautier, Francois Bartolo, Florian Rohart.</p>


<h3>References</h3>

<p>mixOmics article:
</p>
<p>Rohart F, Gautier B, Singh A, Lê Cao K-A. mixOmics: an R package for 'omics feature selection and multiple data integration. PLoS Comput Biol 13(11): e1005752
</p>


<h3>See Also</h3>

<p><code><a href="splsda.html">splsda</a></code>, <code><a href="predict.html">predict.splsda</a></code> and http://www.mixOmics.org for more details.</p>


<h3>Examples</h3>

<pre>
## First example: analysis with sPLS-DA

data(breast.tumors)
X = breast.tumors$gene.exp
Y = as.factor(breast.tumors$sample$treatment)
tune = tune.splsda(X, Y, ncomp = 1, nrepeat = 10, logratio = "none",
test.keepX = c(5, 10, 15), folds = 10, dist = "max.dist",
progressBar = TRUE)

## Not run: 

# 5 components, optimising 'keepX' and 'ncomp'
tune = tune.splsda(X, Y, ncomp = 5, test.keepX = c(5, 10, 15),
folds = 10, dist = "max.dist", nrepeat = 5, progressBar = TRUE)

tune$choice.ncomp
tune$choice.keepX
plot(tune)


## only tune component 3 and 4
# keeping 5 and 10 variables on the first two components respectively

tune = tune.splsda(X = X,Y = Y, ncomp = 4,
already.tested.X = c(5,10),
test.keepX = seq(1,10,2), progressBar = TRUE)





## Second example: multilevel one-factor analysis with sPLS-DA

data(vac18)
X = vac18$genes
Y = vac18$stimulation
# sample indicates the repeated measurements
design = data.frame(sample = vac18$sample)

tune = tune.splsda(X, Y = Y, ncomp = 3, nrepeat = 10, logratio = "none",
test.keepX = c(5,50,100),folds = 10, dist = "max.dist", multilevel = design)


## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>mixOmics</em> version 6.6.2 <a href="00Index.html">Index</a>]</div>
</body></html>
