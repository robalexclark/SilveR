<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Principal Components Analysis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for pca {mixOmics}"><tr><td>pca {mixOmics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Principal Components Analysis</h2>

<h3>Description</h3>

<p>Performs a principal components analysis on the given data matrix that can
contain missing values. If data are complete 'pca' uses Singular Value
Decomposition, if there are some missing values, it uses the NIPALS
algorithm.
</p>


<h3>Usage</h3>

<pre>
pca(
  X,
  ncomp = 2,
  center = TRUE,
  scale = FALSE,
  max.iter = 500,
  tol = 1e-09,
  logratio = c("none", "CLR", "ILR"),
  ilr.offset = 0.001,
  V = NULL,
  multilevel = NULL
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>a numeric matrix (or data frame) which provides the data for the
principal components analysis. It can contain missing values in which case
<code>center = TRUE</code> is used as required by the
<code><a href="../../mixOmics/help/nipals.html">nipals</a></code> function.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>Integer, if data is complete <code>ncomp</code> decides the number of
components and associated eigenvalues to display from the <code>pcasvd</code>
algorithm and if the data has missing values, <code>ncomp</code> gives the number
of components to keep to perform the reconstitution of the data using the
NIPALS algorithm. If <code>NULL</code>, function sets <code>ncomp = min(nrow(X),
ncol(X))</code></p>
</td></tr>
<tr valign="top"><td><code>center</code></td>
<td>
<p>(Default=TRUE) Logical, whether the variables should be shifted
to be zero centered. Only set to FALSE if data have already been centered.
Alternatively, a vector of length equal the number of columns of <code>X</code>
can be supplied. The value is passed to <code><a href="../../base/html/scale.html">scale</a></code>. If the data
contain missing values, columns should be centered for reliable results.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>(Default=FALSE) Logical indicating whether the variables should be
scaled to have unit variance before the analysis takes place. The default is
<code>FALSE</code> for consistency with <code>prcomp</code> function, but in general
scaling is advisable. Alternatively, a vector of length equal the number of
columns of <code>X</code> can be supplied. The value is passed to
<code><a href="../../base/html/scale.html">scale</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>Integer, the maximum number of iterations in the NIPALS
algorithm.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>Positive real, the tolerance used in the NIPALS algorithm.</p>
</td></tr>
<tr valign="top"><td><code>logratio</code></td>
<td>
<p>(Default='none') one of ('none','CLR','ILR'). Specifies the log ratio
transformation to deal with compositional values that may arise from
specific normalisation in sequencing data. Default to 'none'</p>
</td></tr>
<tr valign="top"><td><code>ilr.offset</code></td>
<td>
<p>(Default=0.001) When logratio is set to 'ILR', an offset must be input to
avoid infinite value after the logratio transform.</p>
</td></tr>
<tr valign="top"><td><code>V</code></td>
<td>
<p>Matrix used in the logratio transformation if provided.</p>
</td></tr>
<tr valign="top"><td><code>multilevel</code></td>
<td>
<p>sample information for multilevel decomposition for
repeated measurements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation is done either by a singular value decomposition of the
(possibly centered and scaled) data matrix, if the data is complete or by
using the NIPALS algorithm if there is data missing. Unlike
<code><a href="../../stats/html/princomp.html">princomp</a></code>, the print method for these objects prints the
results in a nice format and the <code>plot</code> method produces a bar plot of
the percentage of variance explained by the principal components (PCs).
</p>
<p>When using NIPALS (missing values), we make the assumption that the first
(<code>min(ncol(X),</code> <code>nrow(X)</code>) principal components will account for
100 % of the explained variance.
</p>
<p>Note that <code>scale = TRUE</code> will throw an error if there are constant
variables in the data, in which case it's best to filter these variables
in advance.
</p>
<p>According to Filzmoser et al., a ILR log ratio transformation is more
appropriate for PCA with compositional data. Both CLR and ILR are valid.
</p>
<p>Logratio transform and multilevel analysis are performed sequentially as
internal pre-processing step, through <code><a href="../../mixOmics/help/logratio.transfo.html">logratio.transfo</a></code> and
<code><a href="../../mixOmics/help/withinVariation.html">withinVariation</a></code> respectively.
</p>
<p>Logratio can only be applied if the data do not contain any 0 value (for
count data, we thus advise the normalise raw data with a 1 offset). For ILR
transformation and additional offset might be needed.
</p>


<h3>Value</h3>

<p><code>pca</code> returns a list with class <code>"pca"</code> and <code>"prcomp"</code>
containing the following components: 
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>call</code></td>
<td>
<p>The function call.</p>
</td></tr>
<tr valign="top"><td><code>X</code></td>
<td>
<p>The input data matrix, possibly scaled and centered.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>The number of principal components used.</p>
</td></tr>
<tr valign="top"><td><code>center</code></td>
<td>
<p>The centering used.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>The scaling used.</p>
</td></tr>
<tr valign="top"><td><code>names</code></td>
<td>
<p>List of row and column names of data.</p>
</td></tr>
<tr valign="top"><td><code>sdev</code></td>
<td>
<p>The eigenvalues of the covariance/correlation matrix, though
the calculation is actually done with the singular values of the data
matrix or by using NIPALS.</p>
</td></tr>
<tr valign="top"><td><code>loadings</code></td>
<td>
<p>A length one list of matrix of variable loadings for X (i.e.,
a matrix whose columns contain the eigenvectors).</p>
</td></tr> 
<tr valign="top"><td><code>variates</code></td>
<td>
<p>Matrix containing the coordinate values corresponding to the
projection of the samples in the space spanned by the principal components.
These are the dimension-reduced representation of observations/samples.</p>
</td></tr>
<tr valign="top"><td><code>var.tot</code></td>
<td>
<p>Total variance in the data.</p>
</td></tr>
<tr valign="top"><td><code>prop_expl_var</code></td>
<td>
<p>Proportion of variance explained per
component after setting possible missing values in the data to zero (note
that contrary to PCA, this amount may not decrease as the aim of the method
is not to maximise the variance, but the covariance between X and the
dummy matrix Y).</p>
</td></tr>
<tr valign="top"><td><code>cum.var</code></td>
<td>
<p>The cumulative explained variance for components.</p>
</td></tr>
<tr valign="top"><td><code>Xw</code></td>
<td>
<p>If multilevel, the data matrix with within-group-variation removed.</p>
</td></tr>
<tr valign="top"><td><code>design</code></td>
<td>
<p>If multilevel, the provided design.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Rohart, Kim-Anh Lê Cao, Ignacio González, Al J Abadi
</p>


<h3>References</h3>

<p>On log ratio transformations: Filzmoser, P., Hron, K., Reimann,
C.: Principal component analysis for compositional data with outliers.
Environmetrics 20(6), 621-632 (2009) Lê Cao K.-A., Costello ME, Lakis VA,
Bartolo, F,Chua XY, Brazeilles R, Rondeau P. MixMC: Multivariate insights
into Microbial Communities. PLoS ONE, 11(8): e0160169 (2016). On multilevel
decomposition: Westerhuis, J.A., van Velzen, E.J., Hoefsloot, H.C., Smilde,
A.K.: Multivariate paired data analysis: multilevel plsda versus oplsda.
Metabolomics 6(1), 119-128 (2010) Liquet, B., Lê Cao, K.-A., Hocini, H.,
Thiebaut, R.: A novel approach for biomarker selection and the integration
of repeated measures experiments from two assays. BMC bioinformatics 13(1),
325 (2012)
</p>


<h3>See Also</h3>

<p><code><a href="../../mixOmics/help/nipals.html">nipals</a></code>, <code><a href="../../stats/html/prcomp.html">prcomp</a></code>, <code><a href="../../mixOmics/help/biplot.html">biplot</a></code>,
<code><a href="../../mixOmics/help/plotIndiv.html">plotIndiv</a></code>, <code><a href="../../mixOmics/help/plotVar.html">plotVar</a></code> and http://www.mixOmics.org
for more details.
</p>


<h3>Examples</h3>

<pre>
# example with missing values where NIPALS is applied
# --------------------------------
data(multidrug)
X &lt;- multidrug$ABC.trans
pca.res &lt;- pca(X, ncomp = 4, scale = TRUE)
plot(pca.res)
print(pca.res)
biplot(pca.res, group = multidrug$cell.line$Class, legend.title = 'Class')

# samples representation
plotIndiv(pca.res, ind.names = multidrug$cell.line$Class,
    group = as.numeric(as.factor(multidrug$cell.line$Class)))

# variable representation
plotVar(pca.res, var.names = TRUE, cutoff = 0.4, pch = 16)

## Not run: 
plotIndiv(pca.res, cex = 0.2,
    col = as.numeric(as.factor(multidrug$cell.line$Class)),style="3d")


plotVar(pca.res, rad.in = 0.5, cex = 0.5, style="3d")

## End(Not run)

# example with imputing the missing values using impute.nipals()
# --------------------------------
data("nutrimouse")
X &lt;- data.matrix(nutrimouse$lipid)
X &lt;- scale(X, center = TRUE, scale = TRUE)
## add missing values to X to impute and compare to actual values
set.seed(42)
na.ind &lt;- sample(seq_along(X), size = 20)
true.values &lt;- X[na.ind]
X[na.ind] &lt;- NA
pca.no.impute &lt;- pca(X, ncomp = 2)
plotIndiv(pca.no.impute, group = nutrimouse$diet, pch = 16)
X.impute &lt;- impute.nipals(X, ncomp = 10)
## compare
cbind('imputed' = round(X.impute[na.ind], 2), 
      'actual' = round(true.values, 2))
## run pca using imputed matrix
pca.impute &lt;- pca(X.impute, ncomp = 2)
plotIndiv(pca.impute, group = nutrimouse$diet, pch = 16)
# example with multilevel decomposition and CLR log ratio transformation 
# (ILR takes longer to run)
# ----------------
data("diverse.16S")
pca.res = pca(X = diverse.16S$data.TSS, ncomp = 3,
    logratio = 'CLR', multilevel = diverse.16S$sample)
plot(pca.res)
plotIndiv(pca.res, ind.names = FALSE, 
          group = diverse.16S$bodysite, 
          title = '16S diverse data',
          legend = TRUE, 
          legend.title = 'Bodysite')
</pre>

<hr /><div style="text-align: center;">[Package <em>mixOmics</em> version 6.18.1 <a href="00Index.html">Index</a>]</div>
</div></body></html>
