<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Sparse Partial Least Squares (sPLS)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for spls {mixOmics}"><tr><td>spls {mixOmics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Sparse Partial Least Squares (sPLS)</h2>

<h3>Description</h3>

<p>Function to perform sparse Partial Least Squares (sPLS). The sPLS approach
combines both integration and variable selection simultaneously on two data
sets in a one-step strategy.
</p>


<h3>Usage</h3>

<pre>
spls(
  X,
  Y,
  ncomp = 2,
  mode = c("regression", "canonical", "invariant", "classic"),
  keepX,
  keepY,
  scale = TRUE,
  tol = 1e-06,
  max.iter = 100,
  near.zero.var = FALSE,
  logratio = "none",
  multilevel = NULL,
  all.outputs = TRUE
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>numeric matrix of predictors with the rows as individual
observations. missing values (<code>NA</code>s) are allowed.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p>numeric matrix of response(s) with the rows as individual
observations matching <code>X</code>. missing values (<code>NA</code>s) are allowed.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>Positive Integer. The number of components to include in the
model. Default to 2.</p>
</td></tr>
<tr valign="top"><td><code>mode</code></td>
<td>
<p>Character string indicating the type of PLS algorithm to use. One
of <code>"regression"</code>, <code>"canonical"</code>, <code>"invariant"</code> or <code>"classic"</code>. See Details.</p>
</td></tr>
<tr valign="top"><td><code>keepX</code></td>
<td>
<p>numeric vector of length <code>ncomp</code>, the number of variables
to keep in <i>X</i>-loadings. By default all variables are kept in the model.</p>
</td></tr>
<tr valign="top"><td><code>keepY</code></td>
<td>
<p>numeric vector of length <code>ncomp</code>, the number of variables</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>Logical. If scale = TRUE, each block is standardized to zero
means and unit variances (default: TRUE)</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>Positive numeric used as convergence criteria/tolerance during the
iterative process. Default to <code>1e-06</code>.</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>Integer, the maximum number of iterations. Default to  100.</p>
</td></tr>
<tr valign="top"><td><code>near.zero.var</code></td>
<td>
<p>Logical, see the internal <code><a href="../../mixOmics/help/nearZeroVar.html">nearZeroVar</a></code>
function (should be set to TRUE in particular for data with many zero
values). Setting this argument to FALSE (when appropriate) will speed up the
computations. Default value is FALSE.</p>
</td></tr>
<tr valign="top"><td><code>logratio</code></td>
<td>
<p>Character, one of ('none','CLR') specifies
the log ratio transformation to deal with compositional values that may
arise from specific normalisation in sequencing data. Default to 'none'.
See <code>?logratio.transfo</code> for details.</p>
</td></tr>
<tr valign="top"><td><code>multilevel</code></td>
<td>
<p>Numeric, design matrix for repeated measurement analysis,
where multilevel decomposition is required. For a one factor decomposition,
the repeated measures on each individual, i.e. the individuals ID is input
as the first column. For a 2 level factor decomposition then 2nd AND 3rd
columns indicate those factors. See examples.</p>
</td></tr>
<tr valign="top"><td><code>all.outputs</code></td>
<td>
<p>Logical. Computation can be faster when some specific
(and non-essential) outputs are not calculated. Default = <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spls</code> function fit sPLS models with <i>1, &hellip; ,</i><code>ncomp</code>
components. Multi-response models are fully supported. The <code>X</code> and
<code>Y</code> datasets can contain missing values.
</p>


<h3>Value</h3>

<p><code>spls</code> returns an object of class <code>"spls"</code>, a list that
contains the following components:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>the centered and standardized original predictor matrix.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p>the centered and standardized original response vector or matrix.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>the number of components included in the model.</p>
</td></tr>
<tr valign="top"><td><code>mode</code></td>
<td>
<p>the algorithm used to fit the model.</p>
</td></tr> <tr valign="top"><td><code>keepX</code></td>
<td>
<p>number of
<i>X</i> variables kept in the model on each component.</p>
</td></tr> <tr valign="top"><td><code>keepY</code></td>
<td>
<p>number
of <i>Y</i> variables kept in the model on each component.</p>
</td></tr>
<tr valign="top"><td><code>variates</code></td>
<td>
<p>list containing the variates.</p>
</td></tr> <tr valign="top"><td><code>loadings</code></td>
<td>
<p>list
containing the estimated loadings for the <i>X</i> and <i>Y</i> variates.</p>
</td></tr>
<tr valign="top"><td><code>names</code></td>
<td>
<p>list containing the names to be used for individuals and
variables.</p>
</td></tr> <tr valign="top"><td><code>tol</code></td>
<td>
<p>the tolerance used in the iterative algorithm, used
for subsequent S3 methods</p>
</td></tr> <tr valign="top"><td><code>iter</code></td>
<td>
<p>Number of iterations of the algorithm
for each component</p>
</td></tr> <tr valign="top"><td><code>max.iter</code></td>
<td>
<p>the maximum number of iterations, used
for subsequent S3 methods</p>
</td></tr> <tr valign="top"><td><code>nzv</code></td>
<td>
<p>list containing the zero- or near-zero
predictors information.</p>
</td></tr> <tr valign="top"><td><code>scale</code></td>
<td>
<p>whether scaling was applied per
predictor.</p>
</td></tr> <tr valign="top"><td><code>logratio</code></td>
<td>
<p>whether log ratio transformation for relative
proportion data was applied, and if so, which type of transformation.</p>
</td></tr>
<tr valign="top"><td><code>prop_expl_var</code></td>
<td>
<p>Proportion of variance explained per component (note
that contrary to PCA, this amount may not decrease as the aim of the method
is not to maximise the variance, but the covariance between data sets).</p>
</td></tr>
<tr valign="top"><td><code>input.X</code></td>
<td>
<p>numeric matrix of predictors in X that was input, before any
saling / logratio / multilevel transformation.</p>
</td></tr> <tr valign="top"><td><code>mat.c</code></td>
<td>
<p>matrix of
coefficients from the regression of X / residual matrices X on the
X-variates, to be used internally by <code>predict</code>.</p>
</td></tr>
<tr valign="top"><td><code>defl.matrix</code></td>
<td>
<p>residual matrices X for each dimension.</p>
</td></tr>
</table>


<h3>missing values</h3>

<p>The estimation of the missing values can be performed using the
<code><a href="../../mixOmics/help/impute.nipals.html">impute.nipals</a></code> function. Otherwise, missing values are handled
by element-wise deletion in the <code>pls</code> function without having to delete
the rows with missing data.
</p>


<h3>multilevel</h3>

<p>Multilevel (s)PLS enables the integration of data measured on two different
data sets on the same individuals. This approach differs from multilevel
sPLS-DA as the aim is to select subsets of variables from both data sets that
are highly positively or negatively correlated across samples. The approach
is unsupervised, i.e. no prior knowledge about the sample groups is included.
</p>


<h3>logratio and multilevel</h3>

<p>logratio transform and multilevel analysis are performed sequentially as
internal pre-processing step, through <code><a href="../../mixOmics/help/logratio.transfo.html">logratio.transfo</a></code> and
<code><a href="../../mixOmics/help/withinVariation.html">withinVariation</a></code> respectively.
</p>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González, Florian Rohart, Kim-Anh Lê Cao,
Al J abadi
</p>


<h3>References</h3>

<p>Sparse PLS: canonical and regression modes:
</p>
<p>Lê Cao, K.-A., Martin, P.G.P., Robert-Granie, C. and Besse, P. (2009).
Sparse canonical methods for biological data integration: application to a
cross-platform study. <em>BMC Bioinformatics</em> <b>10</b>:34.
</p>
<p>Lê Cao, K.-A., Rossouw, D., Robert-Granie, C. and Besse, P. (2008). A sparse
PLS for variable selection when integrating Omics data. <em>Statistical
Applications in Genetics and Molecular Biology</em> <b>7</b>, article 35.
</p>
<p>Sparse SVD: Shen, H. and Huang, J. Z. (2008). Sparse principal component
analysis via regularized low rank matrix approximation. <em>Journal of
Multivariate Analysis</em> <b>99</b>, 1015-1034.
</p>
<p>PLS methods: Tenenhaus, M. (1998). <em>La regression PLS: theorie et
pratique</em>. Paris: Editions Technic. Chapters 9 and 11.
</p>
<p>Abdi H (2010). Partial least squares regression and projection on latent
structure regression (PLS Regression). <em>Wiley Interdisciplinary
Reviews: Computational Statistics</em>, 2(1), 97-106.
</p>
<p>Wold H. (1966). Estimation of principal components and related models by
iterative least squares. In: Krishnaiah, P. R. (editors), <em>Multivariate
Analysis</em>. Academic Press, N.Y., 391-420.
</p>
<p>On multilevel analysis:
</p>
<p>Liquet, B., Lê Cao, K.-A., Hocini, H. and Thiebaut, R. (2012) A novel
approach for biomarker selection and the integration of repeated measures
experiments from two platforms. <em>BMC Bioinformatics</em> <b>13</b>:325.
</p>
<p>Westerhuis, J. A., van Velzen, E. J., Hoefsloot, H. C., and Smilde, A. K.
(2010). Multivariate paired data analysis: multilevel PLSDA versus OPLSDA.
<em>Metabolomics</em>, <b>6</b>(1), 119-128.
</p>


<h3>See Also</h3>

<p><code><a href="../../mixOmics/help/pls.html">pls</a></code>, <code><a href="../../mixOmics/help/summary.html">summary</a></code>, <code><a href="../../mixOmics/help/plotIndiv.html">plotIndiv</a></code>,
<code><a href="../../mixOmics/help/plotVar.html">plotVar</a></code>, <code><a href="../../mixOmics/help/cim.html">cim</a></code>, <code><a href="../../mixOmics/help/network.html">network</a></code>,
<code><a href="../../mixOmics/help/predict.html">predict</a></code>, <code><a href="../../mixOmics/help/perf.html">perf</a></code> and http://www.mixOmics.org for
more details.
</p>


<h3>Examples</h3>

<pre>
data(liver.toxicity)
X &lt;- liver.toxicity$gene
Y &lt;- liver.toxicity$clinic

toxicity.spls &lt;- spls(X, Y, ncomp = 2, keepX = c(50, 50),
keepY = c(10, 10))

toxicity.spls &lt;- spls(X, Y[,1:2,drop=FALSE], ncomp = 5, keepX = c(50, 50))#,  mode="canonical")

## Not run: 

## Second example: one-factor multilevel analysis with sPLS, selecting a subset of variables
#--------------------------------------------------------------

data(liver.toxicity)
# note: we made up those data, pretending they are repeated measurements
repeat.indiv &lt;- c(1, 2, 1, 2, 1, 2, 1, 2, 3, 3, 4, 3, 4, 3, 4, 4, 5, 6, 5, 5,
6, 5, 6, 7, 7, 8, 6, 7, 8, 7, 8, 8, 9, 10, 9, 10, 11, 9, 9,
10, 11, 12, 12, 10, 11, 12, 11, 12, 13, 14, 13, 14, 13, 14,
13, 14, 15, 16, 15, 16, 15, 16, 15, 16)
summary(as.factor(repeat.indiv)) # 16 rats, 4 measurements each

# this is a spls (unsupervised analysis) so no need to mention any factor in design
# we only perform a one level variation split
design &lt;- data.frame(sample = repeat.indiv)
res.spls.1level &lt;- spls(X = liver.toxicity$gene,
Y=liver.toxicity$clinic,
multilevel = design,
ncomp = 3,
keepX = c(50, 50, 50), keepY = c(5, 5, 5),
mode = 'canonical')

# set up colors and pch for plotIndiv
col.stimu &lt;- 1:nlevels(design$stimu)

plotIndiv(res.spls.1level, rep.space = 'X-variate', ind.names = FALSE,
group = liver.toxicity$treatment$Dose.Group,
pch = 20, main = 'Gene expression subspace',
legend = TRUE)


plotIndiv(res.spls.1level, rep.space = 'Y-variate', ind.names = FALSE,
group = liver.toxicity$treatment$Dose.Group,
pch = 20, main = 'Clinical measurements ssubpace',
legend = TRUE)

plotIndiv(res.spls.1level, rep.space = 'XY-variate', ind.names = FALSE,
group = liver.toxicity$treatment$Dose.Group,
pch = 20, main = 'Both Gene expression and Clinical subspaces',
legend = TRUE)

## Third example: two-factor multilevel analysis with sPLS, selecting a subset of variables
#--------------------------------------------------------------

data(liver.toxicity)
dose &lt;- as.factor(liver.toxicity$treatment$Dose.Group)
time &lt;- as.factor(liver.toxicity$treatment$Time.Group)
# note: we made up those data, pretending they are repeated measurements
repeat.indiv &lt;- c(1, 2, 1, 2, 1, 2, 1, 2, 3, 3, 4, 3, 4, 3, 4, 4, 5, 6, 5, 5,
6, 5, 6, 7, 7, 8, 6, 7, 8, 7, 8, 8, 9, 10, 9, 10, 11, 9, 9,
10, 11, 12, 12, 10, 11, 12, 11, 12, 13, 14, 13, 14, 13, 14,
13, 14, 15, 16, 15, 16, 15, 16, 15, 16)
summary(as.factor(repeat.indiv)) # 16 rats, 4 measurements each
design &lt;- data.frame(sample = repeat.indiv, dose = dose, time = time)

res.spls.2level = spls(liver.toxicity$gene,
Y = liver.toxicity$clinic,
multilevel = design,
ncomp=2,
keepX = c(10,10), keepY = c(5,5))

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>mixOmics</em> version 6.18.1 <a href="00Index.html">Index</a>]</div>
</div></body></html>
