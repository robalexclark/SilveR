<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Predict Method for (mint).(block).(s)pls(da) methods</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for predict {mixOmics}"><tr><td>predict {mixOmics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Predict Method for (mint).(block).(s)pls(da) methods</h2>

<h3>Description</h3>

<p>Predicted values based on PLS models. New responses and variates are
predicted using a fitted model and a new matrix of observations.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'mixo_pls'
predict(
  object,
  newdata,
  study.test,
  dist = c("all", "max.dist", "centroids.dist", "mahalanobis.dist"),
  multilevel = NULL,
  ...
)

## S3 method for class 'mixo_spls'
predict(
  object,
  newdata,
  study.test,
  dist = c("all", "max.dist", "centroids.dist", "mahalanobis.dist"),
  multilevel = NULL,
  ...
)

## S3 method for class 'mint.splsda'
predict(
  object,
  newdata,
  study.test,
  dist = c("all", "max.dist", "centroids.dist", "mahalanobis.dist"),
  multilevel = NULL,
  ...
)

## S3 method for class 'block.pls'
predict(
  object,
  newdata,
  study.test,
  dist = c("all", "max.dist", "centroids.dist", "mahalanobis.dist"),
  multilevel = NULL,
  ...
)

## S3 method for class 'block.spls'
predict(
  object,
  newdata,
  study.test,
  dist = c("all", "max.dist", "centroids.dist", "mahalanobis.dist"),
  multilevel = NULL,
  ...
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
<p>object of class inheriting from
<code>"(mint).(block).(s)pls(da)"</code>.</p>
</td></tr>
<tr valign="top"><td><code>newdata</code></td>
<td>
<p>data matrix in which to look for for explanatory variables to
be used for prediction. Please note that this method does not perform
multilevel decomposition or log ratio transformations, which need to be
processed beforehand.</p>
</td></tr>
<tr valign="top"><td><code>study.test</code></td>
<td>
<p>For MINT objects, grouping factor indicating which samples
of <code>newdata</code> are from the same study. Overlap with <code>object$study</code>
are allowed.</p>
</td></tr>
<tr valign="top"><td><code>dist</code></td>
<td>
<p>distance to be applied for discriminant methods to predict the
class of new data, should be a subset of <code>"centroids.dist"</code>,
<code>"mahalanobis.dist"</code> or <code>"max.dist"</code> (see Details). Defaults to
<code>"all"</code>.</p>
</td></tr>
<tr valign="top"><td><code>multilevel</code></td>
<td>
<p>Design matrix for multilevel analysis (for repeated
measurements). A numeric matrix or data frame. For a one level factor
decomposition, the input is a vector indicating the repeated measures on
each individual, i.e. the individuals ID. For a two level decomposition with
splsda models, the two factors are included in Y. Finally for a two level
decomposition with spls models, 2nd AND 3rd columns in design indicate those
factors (see example in <code>?splsda</code> and <code>?spls</code>).</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict</code> produces predicted values, obtained by evaluating the
PLS-derived methods, returned by <code>(mint).(block).(s)pls(da)</code> in the
frame <code>newdata</code>. Variates for <code>newdata</code> are also returned. Please
note that this method performs multilevel decomposition and/or log ratio
transformations if needed (<code>multilevel</code> is an input parameter while
<code>logratio</code> is extracted from <code>object</code>).
</p>
<p>Different prediction distances are proposed for discriminant analysis. The
reason is that our supervised models work with a dummy indicator matrix of
<code>Y</code> to indicate the class membership of each sample. The prediction of
a new observation results in either a predicted dummy variable (output
<code>object$predict</code>), or a predicted variate (output
<code>object$variates</code>). Therefore, an appropriate distance needs to be
applied to those predicted values to assign the predicted class. We propose
distances such as &lsquo;maximum distance&rsquo; for the predicted dummy variables,
&lsquo;Mahalanobis distance&rsquo; and &lsquo;Centroids distance&rsquo; for the predicted variates.
</p>
<p><code>"max.dist"</code> is the simplest method to predict the class of a test
sample. For each new individual, the class with the largest predicted dummy
variable is the predicted class. This distance performs well in single data
set analysis with multiclass problems (PLS-DA).
</p>
<p><code>"centroids.dist"</code> allocates to the new observation the class that
mimimises the distance between the predicted score and the centroids of the
classes calculated on the latent components or variates of the trained
model.
</p>
<p><code>"mahalanobis.dist"</code> allocates the new sample the class defined as the
centroid distance, but using the Mahalanobis metric in the calculation of
the distance.
</p>
<p>In practice we found that the centroid-based distances
(<code>"centroids.dist"</code> and <code>"mahalanobis.dist"</code>), and specifically
the Mahalanobis distance led to more accurate predictions than the maximum
distance for complex classification problems and N-integration problems
(block.splsda). The centroid distances consider the prediction in
dimensional space spanned by the predicted variates, while the maximum
distance considers a single point estimate using the predicted scores on the
last dimension of the model. The user can assess the different distances,
and choose the prediction distance that leads to the best performance of the
model, as highlighted from the tune and perf outputs
</p>
<p>More (mathematical) details about the prediction distances are available in
the supplemental of the mixOmics article (Rohart et al 2017).
</p>
<p>For a visualisation of those prediction distances, see
<code>background.predict</code> that overlays the prediction area in
<code>plotIndiv</code> for a sPLS-DA object.
</p>
<p>Allocates the individual <i>x</i> to the class of <i>Y</i> minimizing
<i>dist(\code{x-variate}, G_l)</i>, where <i>G_l</i>, <i>l = 1,...,L</i> are
the centroids of the classes calculated on the <i>X</i>-variates of the
model. <code>"mahalanobis.dist"</code> allocates the individual <i>x</i> to the
class of <i>Y</i> as in <code>"centroids.dist"</code> but by using the Mahalanobis
metric in the calculation of the distance.
</p>
<p>For MINT objects, the <code>study.test</code> argument is required and provides
the grouping factor of <code>newdata</code>.
</p>
<p>For multi block analysis (thus block objects), <code>newdata</code> is a list of
matrices whose names are a subset of <code>names(object$X)</code> and missing
blocks are allowed. Several predictions are returned, either for each block
or for all blocks. For non discriminant analysis, the predicted values
(<code>predict</code>) are returned for each block and these values are combined
by average (<code>AveragedPredict</code>) or weighted average
(<code>WeightedPredict</code>), using the weights of the blocks that are
calculated as the correlation between a block's components and the outcome's
components.
</p>
<p>For discriminant analysis, the predicted class is returned for each block
(<code>class</code>) and each distance (<code>dist</code>) and these predictions are
combined by majority vote (<code>MajorityVote</code>) or weighted majority vote
(<code>WeightedVote</code>), using the weights of the blocks that are calculated
as the correlation between a block's components and the outcome's
components. NA means that there is no consensus among the block. For PLS-DA
and sPLS-DA objects, the prediction area can be visualised in plotIndiv via
the <code>background.predict</code> function.
</p>


<h3>Value</h3>

<p><code>predict</code> produces a list with the following components:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>predict</code></td>
<td>
<p>predicted response values. The dimensions correspond to the
observations, the response variables and the model dimension, respectively.
For a supervised model, it corresponds to the predicted dummy variables.</p>
</td></tr>
<tr valign="top"><td><code>variates</code></td>
<td>
<p>matrix of predicted variates.</p>
</td></tr> <tr valign="top"><td><code>B.hat</code></td>
<td>
<p>matrix of
regression coefficients (without the intercept).</p>
</td></tr>
<tr valign="top"><td><code>AveragedPredict</code></td>
<td>
<p>if more than one block, returns the average predicted
values over the blocks (using the <code>predict</code> output)</p>
</td></tr>
<tr valign="top"><td><code>WeightedPredict</code></td>
<td>
<p>if more than one block, returns the weighted average
of the predicted values over the blocks (using the <code>predict</code> and
<code>weights</code> outputs)</p>
</td></tr>
<tr valign="top"><td><code>class</code></td>
<td>
<p>predicted class of <code>newdata</code> for each
<i>1,...,</i><code>ncomp</code> components.</p>
</td></tr>
<tr valign="top"><td><code>MajorityVote</code></td>
<td>
<p>if more than one block, returns the majority class over
the blocks. NA for a sample means that there is no consensus on the
predicted class for this particular sample over the blocks.</p>
</td></tr>
<tr valign="top"><td><code>WeightedVote</code></td>
<td>
<p>if more than one block, returns the weighted majority
class over the blocks. NA for a sample means that there is no consensus on
the predicted class for this particular sample over the blocks.</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
<p>Returns the weights of each block used for the weighted
predictions, for each nrepeat and each fold</p>
</td></tr>
<tr valign="top"><td><code>centroids</code></td>
<td>
<p>matrix of coordinates for centroids.</p>
</td></tr> <tr valign="top"><td><code>dist</code></td>
<td>
<p>type of
distance requested.</p>
</td></tr> <tr valign="top"><td><code>vote</code></td>
<td>
<p>majority vote result for multi block
analysis (see details above).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Rohart, Sébastien Déjean, Ignacio González, Kim-Anh Lê Cao,
Al J Abadi
</p>


<h3>References</h3>

<p>Rohart F, Gautier B, Singh A, Lê Cao K-A. mixOmics: an R package for 'omics
feature selection and multiple data integration. PLoS Comput Biol 13(11):
e1005752
</p>
<p>Tenenhaus, M. (1998). <em>La regression PLS: theorie et pratique</em>. Paris:
Editions Technic.
</p>


<h3>See Also</h3>

<p><code><a href="../../mixOmics/help/pls.html">pls</a></code>, <code><a href="../../mixOmics/help/spls.html">spls</a></code>, <code><a href="../../mixOmics/help/plsda.html">plsda</a></code>,
<code><a href="../../mixOmics/help/splsda.html">splsda</a></code>, <code><a href="../../mixOmics/help/mint.pls.html">mint.pls</a></code>, <code><a href="../../mixOmics/help/mint.spls.html">mint.spls</a></code>,
<code><a href="../../mixOmics/help/mint.plsda.html">mint.plsda</a></code>, <code><a href="../../mixOmics/help/mint.splsda.html">mint.splsda</a></code>,
<code><a href="../../mixOmics/help/block.pls.html">block.pls</a></code>, <code><a href="../../mixOmics/help/block.spls.html">block.spls</a></code>,
<code><a href="../../mixOmics/help/block.plsda.html">block.plsda</a></code>, <code><a href="../../mixOmics/help/block.splsda.html">block.splsda</a></code>,
<code><a href="../../mixOmics/help/mint.block.pls.html">mint.block.pls</a></code>, <code><a href="../../mixOmics/help/mint.block.spls.html">mint.block.spls</a></code>,
<code><a href="../../mixOmics/help/mint.block.plsda.html">mint.block.plsda</a></code>, <code><a href="../../mixOmics/help/mint.block.splsda.html">mint.block.splsda</a></code> and
visualisation with <code><a href="../../mixOmics/help/background.predict.html">background.predict</a></code> and
http://www.mixOmics.org for more details.
</p>


<h3>Examples</h3>

<pre>
data(linnerud)
X &lt;- linnerud$exercise
Y &lt;- linnerud$physiological
linn.pls &lt;- pls(X, Y, ncomp = 2, mode = "classic")

indiv1 &lt;- c(200, 40, 60)
indiv2 &lt;- c(190, 45, 45)
newdata &lt;- rbind(indiv1, indiv2)
colnames(newdata) &lt;- colnames(X)
newdata

pred &lt;- predict(linn.pls, newdata)

plotIndiv(linn.pls, comp = 1:2, rep.space = "X-variate",style="graphics",ind.names=FALSE)
points(pred$variates[, 1], pred$variates[, 2], pch = 19, cex = 1.2)
text(pred$variates[, 1], pred$variates[, 2],
c("new ind.1", "new ind.2"), pos = 3)

## First example with plsda
data(liver.toxicity)
X &lt;- liver.toxicity$gene
Y &lt;- as.factor(liver.toxicity$treatment[, 4])


## if training is perfomed on 4/5th of the original data
samp &lt;- sample(1:5, nrow(X), replace = TRUE)
test &lt;- which(samp == 1)   # testing on the first fold
train &lt;- setdiff(1:nrow(X), test)

plsda.train &lt;- plsda(X[train, ], Y[train], ncomp = 2)
test.predict &lt;- predict(plsda.train, X[test, ], dist = "max.dist")
Prediction &lt;- test.predict$class$max.dist[, 2]
cbind(Y = as.character(Y[test]), Prediction)

## Not run: 
## Second example with splsda
splsda.train &lt;- splsda(X[train, ], Y[train], ncomp = 2, keepX = c(30, 30))
test.predict &lt;- predict(splsda.train, X[test, ], dist = "max.dist")
Prediction &lt;- test.predict$class$max.dist[, 2]
cbind(Y = as.character(Y[test]), Prediction)


## example with block.splsda=diablo=sgccda and a missing block
data(nutrimouse)
# need to unmap Y for an unsupervised analysis, where Y is included as a data block in data
Y.mat = unmap(nutrimouse$diet)
data = list(gene = nutrimouse$gene, lipid = nutrimouse$lipid, Y = Y.mat)
# with this design, all blocks are connected
design = matrix(c(0,1,1,1,0,1,1,1,0), ncol = 3, nrow = 3,
byrow = TRUE, dimnames = list(names(data), names(data)))

# train on 75% of the data
ind.train=NULL
for(i in 1:nlevels(nutrimouse$diet))
ind.train=c(ind.train,which(nutrimouse$diet==levels(nutrimouse$diet)[i])[1:6])

#training set
gene.train=nutrimouse$gene[ind.train,]
lipid.train=nutrimouse$lipid[ind.train,]
Y.mat.train=Y.mat[ind.train,]
Y.train=nutrimouse$diet[ind.train]
data.train=list(gene=gene.train,lipid=lipid.train,Y=Y.mat.train)

#test set
gene.test=nutrimouse$gene[-ind.train,]
lipid.test=nutrimouse$lipid[-ind.train,]
Y.mat.test=Y.mat[-ind.train,]
Y.test=nutrimouse$diet[-ind.train]
data.test=list(gene=gene.test,lipid=lipid.test)

# example with block.splsda=diablo=sgccda and a missing block
res.train = block.splsda(X=list(gene=gene.train,lipid=lipid.train),Y=Y.train,
ncomp=3,keepX=list(gene=c(10,10,10),lipid=c(5,5,5)))
test.predict = predict(res.train, newdata=data.test[2], method = "max.dist")


## example with mint.splsda
data(stemcells)

#training set
ind.test = which(stemcells$study == "3")
gene.train = stemcells$gene[-ind.test,]
Y.train = stemcells$celltype[-ind.test]
study.train = factor(stemcells$study[-ind.test])

#test set
gene.test = stemcells$gene[ind.test,]
Y.test = stemcells$celltype[ind.test]
study.test = factor(stemcells$study[ind.test])

res = mint.splsda(X = gene.train, Y = Y.train, ncomp = 3, keepX = c(10, 5, 15),
study = study.train)

pred = predict(res, newdata = gene.test, study.test = study.test)

data.frame(Truth = Y.test, prediction = pred$class$max.dist)


## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>mixOmics</em> version 6.18.1 <a href="00Index.html">Index</a>]</div>
</div></body></html>
