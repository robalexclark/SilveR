<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Predict Method for (mint).(block).(s)pls(da) methods</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for predict {mixOmics}"><tr><td>predict {mixOmics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Predict Method for (mint).(block).(s)pls(da) methods</h2>

<h3>Description</h3>

<p>Predicted values based on PLS models. New responses and
variates are predicted using a fitted model and a new matrix of observations.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'mint.splsda'
predict(object, newdata, study.test,
dist = c("all", "max.dist", "centroids.dist", "mahalanobis.dist"),
multilevel, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
<p>object of class inheriting from <code>"(mint).(block).(s)pls(da)"</code>.</p>
</td></tr>
<tr valign="top"><td><code>newdata</code></td>
<td>
<p>data matrix in which to look for for explanatory variables to be used for prediction. Please note that this method does not perform multilevel decomposition or log ratio transformations, which need to be processed beforehand.</p>
</td></tr>
<tr valign="top"><td><code>study.test</code></td>
<td>
<p>For MINT objects, grouping factor indicating which samples of <code>newdata</code> are from the same study. Overlap with <code>object$study</code> are allowed.</p>
</td></tr>
<tr valign="top"><td><code>dist</code></td>
<td>
<p>distance to be applied for discriminant methods to predict the class of new data,
should be a subset of <code>"centroids.dist"</code>, <code>"mahalanobis.dist"</code> or <code>"max.dist"</code> (see Details).
Defaults to <code>"all"</code>.</p>
</td></tr>
<tr valign="top"><td><code>multilevel</code></td>
<td>
<p>Design matrix for multilevel analysis (for repeated measurements). A numeric matrix or data frame. For a one level factor decomposition, the input is a vector indicating the repeated measures on each individual, i.e. the individuals ID. For a two level decomposition with splsda models, the two factors are included in Y. Finally for a two level decomposition with spls models, 2nd AND 3rd columns in design indicate those factors (see example in <code>?splsda</code> and <code>?spls</code>).</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>not used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict</code> produces predicted values, obtained by evaluating the PLS-derived methods, returned by <code>(mint).(block).(s)pls(da)</code> in the frame <code>newdata</code>.
Variates for <code>newdata</code> are also returned. Please note that this method performs multilevel decomposition and/or log ratio transformations if needed (<code>multilevel</code> is an input parameter while <code>logratio</code> is extracted from <code>object</code>).
</p>
<p>Different prediction distances are proposed for discriminant analysis. The reason is that our supervised models work with a dummy indicator matrix of <code>Y</code> to indicate the class membership of each sample. The prediction of a new observation results in either a predicted dummy variable (output <code>object$predict</code>), or a predicted variate (output <code>object$variates</code>). Therefore, an appropriate distance needs to be applied to those predicted values to assign the predicted class. We propose distances such as &lsquo;maximum distance&rsquo; for the predicted dummy variables, &lsquo;Mahalanobis distance&rsquo; and &lsquo;Centroids distance&rsquo; for the predicted variates.
</p>
<p><code>"max.dist"</code> is the simplest method to predict the class of a test sample. For each new individual, the class with the largest predicted dummy variable is the predicted class. This distance performs well in single data set analysis with multiclass problems (PLS-DA).
</p>
<p><code>"centroids.dist"</code>  allocates to the new observation the class that mimimises the distance between the predicted score and the centroids of the classes calculated on the latent components or variates of the trained model.
</p>
<p><code>"mahalanobis.dist"</code>  allocates the new sample the class defined as the centroid distance, but using the Mahalanobis metric in the calculation of the distance.
</p>
<p>In practice we found that the centroid-based distances (<code>"centroids.dist"</code> and <code>"mahalanobis.dist"</code>), and specifically the Mahalanobis distance led to more accurate predictions than the maximum distance for complex classification problems and N-integration problems (block.splsda). The centroid distances consider the prediction in dimensional space spanned by the predicted variates, while the maximum distance considers a single point estimate using the predicted scores on the last dimension of the model. The user can assess the different distances, and choose the prediction distance that leads to the best performance of the model, as highlighted from the tune and perf outputs
</p>
<p>More (mathematical) details about the prediction distances are available in the supplemental of the mixOmics article (Rohart et al 2017).
</p>
<p>For a visualisation of those prediction distances, see <code>background.predict</code> that overlays the prediction area in <code>plotIndiv</code> for a sPLS-DA object.
</p>

<p>For MINT objects, the <code>study.test</code> argument is required and provides the grouping factor of <code>newdata</code>.
</p>
<p>For multi block analysis (thus block objects), <code>newdata</code> is a list of matrices whose names are a subset of <code>names(object$X)</code> and missing blocks are allowed. Several predictions are returned, either for each block or for all blocks.
For non discriminant analysis, the predicted values (<code>predict</code>) are returned for each block and these values are combined by average (<code>AveragedPredict</code>) or weighted average (<code>WeightedPredict</code>), using the weights of the blocks that are calculated as the correlation between a block's components and the outcome's components.
</p>
<p>For discriminant analysis, the predicted class is returned for each block (<code>class</code>) and each distance (<code>dist</code>) and these predictions are combined by majority vote (<code>MajorityVote</code>) or weighted majority vote (<code>WeightedVote</code>), using the weights of the blocks that are calculated as the correlation between a block's components and the outcome's components. NA means that there is no consensus among the block. For PLS-DA and sPLS-DA objects, the prediction area can be visualised in plotIndiv via the <code>background.predict</code> function.
</p>


<h3>Value</h3>

<p><code>predict</code> produces a list with the following components:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>predict</code></td>
<td>
<p>predicted response values. The dimensions
correspond to the observations, the response variables and the model dimension, respectively. For a supervised model, it corresponds to the predicted dummy variables.</p>
</td></tr>
<tr valign="top"><td><code>variates</code></td>
<td>
<p>matrix of predicted variates.</p>
</td></tr>
<tr valign="top"><td><code>B.hat</code></td>
<td>
<p>matrix of regression coefficients (without the intercept).</p>
</td></tr>
<tr valign="top"><td><code>AveragedPredict</code></td>
<td>
<p>if more than one block, returns the average predicted values over the blocks (using the <code>predict</code> output)</p>
</td></tr>
<tr valign="top"><td><code>WeightedPredict</code></td>
<td>
<p>if more than one block, returns the weighted average of the predicted values over the blocks (using the <code>predict</code> and <code>weights</code> outputs)</p>
</td></tr>
<tr valign="top"><td><code>class</code></td>
<td>
<p>predicted class of <code>newdata</code> for each <i>1,...,</i><code>ncomp</code> components.</p>
</td></tr>
<tr valign="top"><td><code>MajorityVote</code></td>
<td>
<p>if more than one block, returns the majority class over the blocks. NA for a sample means that there is no consensus on the predicted class for this particular sample over the blocks.</p>
</td></tr>
<tr valign="top"><td><code>WeightedVote</code></td>
<td>
<p>if more than one block, returns the weighted majority class over the blocks. NA for a sample means that there is no consensus on the predicted class for this particular sample over the blocks.</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
<p>Returns the weights of each block used for the weighted predictions, for each nrepeat and each fold</p>
</td></tr>
<tr valign="top"><td><code>centroids</code></td>
<td>
<p>matrix of coordinates for centroids.</p>
</td></tr>
<tr valign="top"><td><code>dist</code></td>
<td>
<p>type of distance requested.</p>
</td></tr>
<tr valign="top"><td><code>vote</code></td>
<td>
<p>majority vote result for multi block analysis (see details above).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Rohart, Sébastien Déjean, Ignacio González, Kim-Anh Lê Cao</p>


<h3>References</h3>

<p>Rohart F, Gautier B, Singh A, Lê Cao K-A. mixOmics: an R package for 'omics feature selection and multiple data integration. PLoS Comput Biol 13(11): e1005752
</p>
<p>Tenenhaus, M. (1998). <em>La regression PLS: theorie et pratique</em>. Paris: Editions Technic.
</p>


<h3>See Also</h3>

<p><code><a href="pls.html">pls</a></code>, <code><a href="spls.html">spls</a></code>, <code><a href="plsda.html">plsda</a></code>, <code><a href="splsda.html">splsda</a></code>,
<code><a href="mint.pls.html">mint.pls</a></code>, <code><a href="mint.spls.html">mint.spls</a></code>, <code><a href="mint.plsda.html">mint.plsda</a></code>, <code><a href="mint.splsda.html">mint.splsda</a></code>,
<code><a href="block.pls.html">block.pls</a></code>, <code><a href="block.spls.html">block.spls</a></code>, <code><a href="block.plsda.html">block.plsda</a></code>, <code><a href="block.splsda.html">block.splsda</a></code>,
<code><a href="mint.block.pls.html">mint.block.pls</a></code>, <code><a href="mint.block.spls.html">mint.block.spls</a></code>, <code><a href="mint.block.plsda.html">mint.block.plsda</a></code>, <code><a href="mint.block.splsda.html">mint.block.splsda</a></code> and visualisation with <code><a href="background.predict.html">background.predict</a></code>
and http://www.mixOmics.org for more details.</p>


<h3>Examples</h3>

<pre>
data(linnerud)
X &lt;- linnerud$exercise
Y &lt;- linnerud$physiological
linn.pls &lt;- pls(X, Y, ncomp = 2, mode = "classic")

indiv1 &lt;- c(200, 40, 60)
indiv2 &lt;- c(190, 45, 45)
newdata &lt;- rbind(indiv1, indiv2)
colnames(newdata) &lt;- colnames(X)
newdata

pred &lt;- predict(linn.pls, newdata)

plotIndiv(linn.pls, comp = 1:2, rep.space = "X-variate",style="graphics",ind.names=FALSE)
points(pred$variates[, 1], pred$variates[, 2], pch = 19, cex = 1.2)
text(pred$variates[, 1], pred$variates[, 2],
c("new ind.1", "new ind.2"), pos = 3)

## First example with plsda
data(liver.toxicity)
X &lt;- liver.toxicity$gene
Y &lt;- as.factor(liver.toxicity$treatment[, 4])


## if training is perfomed on 4/5th of the original data
samp &lt;- sample(1:5, nrow(X), replace = TRUE)
test &lt;- which(samp == 1)   # testing on the first fold
train &lt;- setdiff(1:nrow(X), test)

plsda.train &lt;- plsda(X[train, ], Y[train], ncomp = 2)
test.predict &lt;- predict(plsda.train, X[test, ], dist = "max.dist")
Prediction &lt;- test.predict$class$max.dist[, 2]
cbind(Y = as.character(Y[test]), Prediction)

## Not run: 
## Second example with splsda
splsda.train &lt;- splsda(X[train, ], Y[train], ncomp = 2, keepX = c(30, 30))
test.predict &lt;- predict(splsda.train, X[test, ], dist = "max.dist")
Prediction &lt;- test.predict$class$max.dist[, 2]
cbind(Y = as.character(Y[test]), Prediction)


## example with block.splsda=diablo=sgccda and a missing block
data(nutrimouse)
# need to unmap Y for an unsupervised analysis, where Y is included as a data block in data
Y.mat = unmap(nutrimouse$diet)
data = list(gene = nutrimouse$gene, lipid = nutrimouse$lipid, Y = Y.mat)
# with this design, all blocks are connected
design = matrix(c(0,1,1,1,0,1,1,1,0), ncol = 3, nrow = 3,
byrow = TRUE, dimnames = list(names(data), names(data)))

# train on 75
ind.train=NULL
for(i in 1:nlevels(nutrimouse$diet))
ind.train=c(ind.train,which(nutrimouse$diet==levels(nutrimouse$diet)[i])[1:6])

#training set
gene.train=nutrimouse$gene[ind.train,]
lipid.train=nutrimouse$lipid[ind.train,]
Y.mat.train=Y.mat[ind.train,]
Y.train=nutrimouse$diet[ind.train]
data.train=list(gene=gene.train,lipid=lipid.train,Y=Y.mat.train)

#test set
gene.test=nutrimouse$gene[-ind.train,]
lipid.test=nutrimouse$lipid[-ind.train,]
Y.mat.test=Y.mat[-ind.train,]
Y.test=nutrimouse$diet[-ind.train]
data.test=list(gene=gene.test,lipid=lipid.test)

# example with block.splsda=diablo=sgccda and a missing block
res.train = block.splsda(X=list(gene=gene.train,lipid=lipid.train),Y=Y.train,
ncomp=3,keepX=list(gene=c(10,10,10),lipid=c(5,5,5)))
test.predict = predict(res.train, newdata=data.test[2], method = "max.dist")


## example with mint.splsda
data(stemcells)

#training set
ind.test = which(stemcells$study == "3")
gene.train = stemcells$gene[-ind.test,]
Y.train = stemcells$celltype[-ind.test]
study.train = factor(stemcells$study[-ind.test])

#test set
gene.test = stemcells$gene[ind.test,]
Y.test = stemcells$celltype[ind.test]
study.test = factor(stemcells$study[ind.test])

res = mint.splsda(X = gene.train, Y = Y.train, ncomp = 3, keepX = c(10, 5, 15),
study = study.train)

pred = predict(res, newdata = gene.test, study.test = study.test)

data.frame(Truth = Y.test, prediction = pred$class$max.dist)


## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>mixOmics</em> version 6.6.2 <a href="00Index.html">Index</a>]</div>
</body></html>
