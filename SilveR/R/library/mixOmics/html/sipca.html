<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Independent Principal Component Analysis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for sipca {mixOmics}"><tr><td>sipca {mixOmics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Independent Principal Component Analysis</h2>

<h3>Description</h3>

<p>Performs sparse independent principal component analysis on the given data
matrix to enable variable selection.
</p>


<h3>Usage</h3>

<pre>
sipca(
  X,
  ncomp = 3,
  mode = c("deflation", "parallel"),
  fun = c("logcosh", "exp"),
  scale = FALSE,
  max.iter = 200,
  tol = 1e-04,
  keepX = rep(50, ncomp),
  w.init = NULL
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>a numeric matrix (or data frame).</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>integer, number of independent component to choose. Set by
default to 3.</p>
</td></tr>
<tr valign="top"><td><code>mode</code></td>
<td>
<p>character string. What type of algorithm to use when estimating
the unmixing matrix, choose one of <code>"deflation"</code>, <code>"parallel"</code>.
Default set to <code>deflation</code>.</p>
</td></tr>
<tr valign="top"><td><code>fun</code></td>
<td>
<p>the function used in approximation to neg-entropy in the FastICA
algorithm. Default set to <code>logcosh</code>, see details of FastICA.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>(Default=FALSE) Logical indicating whether the variables should be
scaled to have unit variance before the analysis takes place. The default is
<code>FALSE</code> for consistency with <code>prcomp</code> function, but in general
scaling is advisable. Alternatively, a vector of length equal the number of
columns of <code>X</code> can be supplied. The value is passed to
<code><a href="../../base/html/scale.html">scale</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>integer, the maximum number of iterations.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>a positive scalar giving the tolerance at which the un-mixing
matrix is considered to have converged, see fastICA package.</p>
</td></tr>
<tr valign="top"><td><code>keepX</code></td>
<td>
<p>the number of variable to keep on each dimensions.</p>
</td></tr>
<tr valign="top"><td><code>w.init</code></td>
<td>
<p>initial un-mixing matrix (unlike fastICA, this matrix is fixed
here).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Details of ipca.
</p>
<p>Soft thresholding is implemented on the independent loading vectors to
obtain sparse loading vectors and enable variable selection.
</p>


<h3>Value</h3>

<p><code>pca</code> returns a list with class <code>"ipca"</code> containing the
following components: </p>
<table summary="R valueblock">
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>the number of principal components used.</p>
</td></tr>
<tr valign="top"><td><code>unmixing</code></td>
<td>
<p>the unmixing matrix of size (ncomp x ncomp)</p>
</td></tr>
<tr valign="top"><td><code>mixing</code></td>
<td>
<p>the mixing matrix of size (ncomp x ncomp</p>
</td></tr> <tr valign="top"><td><code>X</code></td>
<td>
<p>the
centered data matrix</p>
</td></tr> <tr valign="top"><td><code>x</code></td>
<td>
<p>the principal components (with sparse
independent loadings)</p>
</td></tr> <tr valign="top"><td><code>loadings</code></td>
<td>
<p>the sparse independent loading
vectors</p>
</td></tr> 
<tr valign="top"><td><code>kurtosis</code></td>
<td>
<p>the kurtosis measure of the independent loading
vectors</p>
</td></tr>
<tr valign="top"><td><code>prop_expl_var</code></td>
<td>
<p>Proportion of the explained variance of derived
components, after setting possible missing values to zero.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fangzhou Yao, Jeff Coquery, Francois Bartolo, Kim-Anh Lê Cao, Al J Abadi
</p>


<h3>References</h3>

<p>Yao, F., Coquery, J. and Lê Cao, K.-A. (2011) Principal
component analysis with independent loadings: a combination of PCA and ICA.
(in preparation)
</p>
<p>A. Hyvarinen and E. Oja (2000) Independent Component Analysis: Algorithms
and Applications, <em>Neural Networks</em>, <b>13(4-5)</b>:411-430
</p>
<p>J L Marchini, C Heaton and B D Ripley (2010). fastICA: FastICA Algorithms to
perform ICA and Projection Pursuit. R package version 1.1-13.
</p>


<h3>See Also</h3>

<p><code><a href="../../mixOmics/help/ipca.html">ipca</a></code>, <code><a href="../../mixOmics/help/pca.html">pca</a></code>, <code><a href="../../mixOmics/help/plotIndiv.html">plotIndiv</a></code>,
<code><a href="../../mixOmics/help/plotVar.html">plotVar</a></code> and http://www.mixOmics.org for more details.
</p>


<h3>Examples</h3>

<pre>
data(liver.toxicity)

# implement IPCA on a microarray dataset
sipca.res &lt;- sipca(liver.toxicity$gene, ncomp = 3, mode="deflation", keepX=c(50,50,50))
sipca.res

# samples representation
plotIndiv(sipca.res, ind.names = liver.toxicity$treatment[, 4],
group = as.numeric(as.factor(liver.toxicity$treatment[, 4])))

## Not run: 
plotIndiv(sipca.res, cex = 0.01, 
          col = as.numeric(as.factor(liver.toxicity$treatment[, 4])), 
          style="3d")

# variables representation
plotVar(sipca.res, cex = 2.5)

plotVar(sipca.res, rad.in = 0.5, cex = .6, style="3d")

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>mixOmics</em> version 6.18.1 <a href="00Index.html">Index</a>]</div>
</div></body></html>
