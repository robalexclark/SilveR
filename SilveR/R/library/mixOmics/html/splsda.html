<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Sparse Partial Least Squares Discriminant Analysis (sPLS-DA)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for splsda {mixOmics}"><tr><td>splsda {mixOmics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Sparse Partial Least Squares Discriminant Analysis (sPLS-DA)</h2>

<h3>Description</h3>

<p>Function to perform sparse Partial Least Squares to classify samples
(supervised analysis) and select variables.
</p>


<h3>Usage</h3>

<pre>
splsda(
  X,
  Y,
  ncomp = 2,
  keepX,
  scale = TRUE,
  tol = 1e-06,
  max.iter = 100,
  near.zero.var = FALSE,
  logratio = "none",
  multilevel = NULL,
  all.outputs = TRUE
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>numeric matrix of predictors with the rows as individual
observations. missing values (<code>NA</code>s) are allowed.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p>a factor or a class vector for the discrete outcome.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>Positive Integer. The number of components to include in the
model. Default to 2.</p>
</td></tr>
<tr valign="top"><td><code>keepX</code></td>
<td>
<p>numeric vector of length <code>ncomp</code>, the number of variables
to keep in <i>X</i>-loadings. By default all variables are kept in the model.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>Logical. If scale = TRUE, each block is standardized to zero
means and unit variances (default: TRUE)</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>Positive numeric used as convergence criteria/tolerance during the
iterative process. Default to <code>1e-06</code>.</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>Integer, the maximum number of iterations. Default to  100.</p>
</td></tr>
<tr valign="top"><td><code>near.zero.var</code></td>
<td>
<p>Logical, see the internal <code><a href="../../mixOmics/help/nearZeroVar.html">nearZeroVar</a></code>
function (should be set to TRUE in particular for data with many zero
values). Setting this argument to FALSE (when appropriate) will speed up the
computations. Default value is FALSE.</p>
</td></tr>
<tr valign="top"><td><code>logratio</code></td>
<td>
<p>Character, one of ('none','CLR') specifies
the log ratio transformation to deal with compositional values that may
arise from specific normalisation in sequencing data. Default to 'none'.
See <code>?logratio.transfo</code> for details.</p>
</td></tr>
<tr valign="top"><td><code>multilevel</code></td>
<td>
<p>sample information for multilevel decomposition for
repeated measurements. A numeric matrix or data frame indicating the
repeated measures on each individual, i.e. the individuals ID. See examples
in <code>?splsda</code>.</p>
</td></tr>
<tr valign="top"><td><code>all.outputs</code></td>
<td>
<p>Logical. Computation can be faster when some specific
(and non-essential) outputs are not calculated. Default = <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>splsda</code> function fits an sPLS model with <i>1, &hellip; ,</i><code>ncomp</code>
components to the factor or class vector <code>Y</code>. The appropriate indicator
(dummy) matrix is created. 
</p>
<p>Logratio transformation and multilevel analysis are
performed sequentially as internal pre-processing step, through
<code><a href="../../mixOmics/help/logratio.transfo.html">logratio.transfo</a></code> and <code><a href="../../mixOmics/help/withinVariation.html">withinVariation</a></code>
respectively. Logratio can only be applied if the data do not contain any 0 value (for
count data, we thus advise the normalise raw data with a 1 offset).
</p>
<p>The type of deflation used is <code>'regression'</code> for discriminant algorithms.
i.e. no deflation is performed on Y.
</p>


<h3>Value</h3>

<p><code>splsda</code> returns an object of class <code>"splsda"</code>, a list
that contains the following components:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>the centered and standardized original predictor matrix.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p>the centered and standardized indicator response vector or matrix.</p>
</td></tr>
<tr valign="top"><td><code>ind.mat</code></td>
<td>
<p>the indicator matrix.</p>
</td></tr> <tr valign="top"><td><code>ncomp</code></td>
<td>
<p>the number of components
included in the model.</p>
</td></tr> <tr valign="top"><td><code>keepX</code></td>
<td>
<p>number of <i>X</i> variables kept in the
model on each component.</p>
</td></tr> <tr valign="top"><td><code>variates</code></td>
<td>
<p>list containing the variates.</p>
</td></tr>
<tr valign="top"><td><code>loadings</code></td>
<td>
<p>list containing the estimated loadings for the <code>X</code> and
<code>Y</code> variates.</p>
</td></tr> <tr valign="top"><td><code>names</code></td>
<td>
<p>list containing the names to be used for
individuals and variables.</p>
</td></tr> <tr valign="top"><td><code>nzv</code></td>
<td>
<p>list containing the zero- or
near-zero predictors information.</p>
</td></tr> <tr valign="top"><td><code>tol</code></td>
<td>
<p>the tolerance used in the
iterative algorithm, used for subsequent S3 methods</p>
</td></tr> <tr valign="top"><td><code>iter</code></td>
<td>
<p>Number of
iterations of the algorithm for each component</p>
</td></tr> <tr valign="top"><td><code>max.iter</code></td>
<td>
<p>the maximum
number of iterations, used for subsequent S3 methods</p>
</td></tr> <tr valign="top"><td><code>scale</code></td>
<td>
<p>Logical
indicating whether the data were scaled in MINT S3 methods</p>
</td></tr>
<tr valign="top"><td><code>logratio</code></td>
<td>
<p>whether logratio transformations were used for compositional
data</p>
</td></tr> <tr valign="top"><td><code>prop_expl_var</code></td>
<td>
<p>Proportion of variance explained per
component after setting possible missing values in the data to zero (note
that contrary to PCA, this amount may not decrease as the aim of the method
is not to maximise the variance, but the covariance between X and the
dummy matrix Y).</p>
</td></tr> <tr valign="top"><td><code>mat.c</code></td>
<td>
<p>matrix of coefficients from the regression of
X / residual matrices X on the X-variates, to be used internally by
<code>predict</code>.</p>
</td></tr> <tr valign="top"><td><code>defl.matrix</code></td>
<td>
<p>residual matrices X for each dimension.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Rohart, Ignacio González, Kim-Anh Lê Cao, Al J abadi
</p>


<h3>References</h3>

<p>On sPLS-DA: Lê Cao, K.-A., Boitard, S. and Besse, P. (2011).
Sparse PLS Discriminant Analysis: biologically relevant feature selection
and graphical displays for multiclass problems. <em>BMC Bioinformatics</em>
<b>12</b>:253. On log ratio transformations: Filzmoser, P., Hron, K.,
Reimann, C.: Principal component analysis for compositional data with
outliers. Environmetrics 20(6), 621-632 (2009) Lê Cao K.-A., Costello ME,
Lakis VA, Bartolo, F,Chua XY, Brazeilles R, Rondeau P. MixMC: Multivariate
insights into Microbial Communities. PLoS ONE, 11(8): e0160169 (2016). On
multilevel decomposition: Westerhuis, J.A., van Velzen, E.J., Hoefsloot,
H.C., Smilde, A.K.: Multivariate paired data analysis: multilevel plsda
versus oplsda. Metabolomics 6(1), 119-128 (2010) Liquet, B., Lê Cao K.-A.,
Hocini, H., Thiebaut, R.: A novel approach for biomarker selection and the
integration of repeated measures experiments from two assays. BMC
bioinformatics 13(1), 325 (2012)
</p>


<h3>See Also</h3>

<p><code><a href="../../mixOmics/help/spls.html">spls</a></code>, <code><a href="../../mixOmics/help/summary.html">summary</a></code>, <code><a href="../../mixOmics/help/plotIndiv.html">plotIndiv</a></code>,
<code><a href="../../mixOmics/help/plotVar.html">plotVar</a></code>, <code><a href="../../mixOmics/help/cim.html">cim</a></code>, <code><a href="../../mixOmics/help/network.html">network</a></code>,
<code><a href="../../mixOmics/help/predict.html">predict</a></code>, <code><a href="../../mixOmics/help/perf.html">perf</a></code>, <code><a href="../../mixOmics/help/mint.block.splsda.html">mint.block.splsda</a></code>,
<code><a href="../../mixOmics/help/block.splsda.html">block.splsda</a></code> and http://www.mixOmics.org for more details.
</p>


<h3>Examples</h3>

<pre>
## First example
data(breast.tumors)
X &lt;- breast.tumors$gene.exp
# Y will be transformed as a factor in the function,
# but we set it as a factor to set up the colors.
Y &lt;- as.factor(breast.tumors$sample$treatment)

res &lt;- splsda(X, Y, ncomp = 2, keepX = c(25, 25))


# individual names appear
plotIndiv(res, ind.names = Y, legend = TRUE, ellipse =TRUE)

## Not run: 
## Second example: one-factor analysis with sPLS-DA, selecting a subset of variables
# as in the paper Liquet et al.
#--------------------------------------------------------------
data(vac18)
X &lt;- vac18$genes
Y &lt;- vac18$stimulation
# sample indicates the repeated measurements
design &lt;- data.frame(sample = vac18$sample)
Y = data.frame(stimul = vac18$stimulation)

# multilevel sPLS-DA model
res.1level &lt;- splsda(X, Y = Y, ncomp = 3, multilevel = design,
keepX = c(30, 137, 123))

# set up colors for plotIndiv
col.stim &lt;- c("darkblue", "purple", "green4","red3")
plotIndiv(res.1level, ind.names = Y, col.per.group = col.stim)

## Third example: two-factor analysis with sPLS-DA, selecting a subset of variables
# as in the paper Liquet et al.
#--------------------------------------------------------------

data(vac18.simulated) # simulated data

X &lt;- vac18.simulated$genes
design &lt;- data.frame(sample = vac18.simulated$sample)
Y = data.frame( stimu = vac18.simulated$stimulation,
time = vac18.simulated$time)

res.2level &lt;- splsda(X, Y = Y, ncomp = 2, multilevel = design,
keepX = c(200, 200))

plotIndiv(res.2level, group = Y$stimu, ind.names = vac18.simulated$time,
legend = TRUE, style = 'lattice')



## Fourth example: with more than two classes
# ------------------------------------------------

data(liver.toxicity)
X &lt;- as.matrix(liver.toxicity$gene)
# Y will be transformed as a factor in the function,
# but we set it as a factor to set up the colors.
Y &lt;- as.factor(liver.toxicity$treatment[, 4])

splsda.liver &lt;- splsda(X, Y, ncomp = 2, keepX = c(20, 20))

# individual name is set to the treatment
plotIndiv(splsda.liver, ind.names = Y, ellipse = TRUE, legend = TRUE)


## Fifth example: 16S data with multilevel decomposion and log ratio transformation
# ------------------------------------------------

splsda.16S = splsda(
X = diverse.16S$data.TSS,  # TSS normalised data
Y =  diverse.16S$bodysite,
multilevel = diverse.16S$sample, # multilevel decomposition
ncomp = 2,
keepX =  c(10, 150),
logratio= 'CLR')  # CLR log ratio transformation


plotIndiv(splsda.16S, ind.names = FALSE, pch = 16, ellipse = TRUE, legend = TRUE)
#OTUs selected at the family level
diverse.16S$taxonomy[selectVar(splsda.16S, comp = 1)$name,'Family']

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>mixOmics</em> version 6.18.1 <a href="00Index.html">Index</a>]</div>
</div></body></html>
