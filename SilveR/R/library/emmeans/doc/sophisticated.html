<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="emmeans package, Version 1.4.6" />


<title>Sophisticated models in emmeans</title>






<style type="text/css">body {font-size: 11pt; font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;margin: 30px 50px 30px 50px; }h1,h2,h3,h4,h5,h6 { font-family: Arial,Helvetica,Sans-serif; }a { text-decoration: none; }a:link { color:darkblue; } a:visited { color:darkblue; } a:hover { color:dodgerblue; }a:active { color:dodgerblue; } code {color: #602000;font-family: "Lucida Console", Monaco, monospace; font-size: 90%;}.r { color: darkred; }.ro { color: darkgreen; background-color: #eeeeee; }.r code, a code, .ro code { color: inherit; }.vigindex ul { list-style-type: none; }.vigindex ul li { list-style: none; }.vigindex a code { color: inherit; }.vigindex li code { color: inherit; }</style>




</head>

<body>




<h1 class="title toc-ignore">Sophisticated models in emmeans</h1>
<h4 class="author">emmeans package, Version 1.4.6</h4>



<!-- @index Vignettes!Sophisticated models -->
<p>This vignette gives a few examples of the use of the <strong>emmeans</strong> package to analyze other than the basic types of models provided by the <strong>stats</strong> package. Emphasis here is placed on accessing the optional capabilities that are typically not needed for the more basic models. A reference for all supported models is provided in the <a href="models.html">“models” vignette</a>.</p>
<div id="contents" class="section level2">
<h2>Contents</h2>
<ol style="list-style-type: decimal">
<li><a href="#lmer">Linear mixed models (lmer)</a>
<ol style="list-style-type: lower-alpha">
<li><a href="#lmerOpts">System options for lmerMod models</a></li>
</ol></li>
<li><a href="#offsets">Models with offsets</a></li>
<li><a href="#ordinal">Ordinal models</a></li>
<li><a href="#mcmc">Models fitted using MCMC methods</a></li>
</ol>
<p><a href="vignette-topics.html">Index of all vignette topics</a></p>
</div>
<div id="lmer" class="section level2">
<h2>Linear mixed models (lmer)</h2>
<!-- @index `lmerMod` models; Examples!`Oats`; Examples!Split-plot experiment -->
<p>Linear mixed models are really important in statistics. Emphasis here is placed on those fitted using <code>lme4::lmer()</code>, but <strong>emmeans</strong> also supports other mixed-model packages such as <strong>nlme</strong>.</p>
<p>To illustrate, consider the <code>Oats</code> dataset in the <strong>nlme</strong> package. It has the results of a balanced split-plot experiment: experimental blocks are divided into plots that are randomly assigned to oat varieties, and the plots are subdivided into subplots that are randomly assigned to amounts of nitrogen within each plot. We will consider a linear mixed model for these data, excluding interaction (which is justified in this case). For sake of illustration, we will exclude a few observations.</p>
<pre class="r"><code>Oats.lmer &lt;- lme4::lmer(yield ~ Variety + factor(nitro) + (1|Block/Variety),
                        data = nlme::Oats, subset = -c(1,2,3,5,8,13,21,34,55))</code></pre>
<p>Let’s look at the EMMs for <code>nitro</code>:</p>
<pre class="r"><code>Oats.emm.n &lt;- emmeans(Oats.lmer, &quot;nitro&quot;)
Oats.emm.n</code></pre>
<pre class="ro"><code>##  nitro emmean   SE   df lower.CL upper.CL
##    0.0   78.9 7.29 7.78     62.0     95.8
##    0.2   97.0 7.14 7.19     80.3    113.8
##    0.4  114.2 7.14 7.19     97.4    131.0
##    0.6  124.1 7.07 6.95    107.3    140.8
## 
## Results are averaged over the levels of: Variety 
## Degrees-of-freedom method: kenward-roger 
## Confidence level used: 0.95</code></pre>
<p>You will notice that the degrees of freedom are fractional: that is due to the fact that whole-plot and subplot variations are combined when standard errors are estimated. Different degrees-of-freedom methods are available. By default, the Kenward-Roger method is used, and that’s why you see a message about the <strong>pbkrtest</strong> package being loaded, as it implements that method. We may specify a different degrees-of-freedom method via the optional argument <code>lmer.df</code>:</p>
<pre class="r"><code>emmeans(Oats.lmer, &quot;nitro&quot;, lmer.df = &quot;satterthwaite&quot;)</code></pre>
<pre class="ro"><code>##  nitro emmean   SE   df lower.CL upper.CL
##    0.0   78.9 7.28 7.28     61.8       96
##    0.2   97.0 7.13 6.72     80.0      114
##    0.4  114.2 7.13 6.72     97.2      131
##    0.6  124.1 7.07 6.49    107.1      141
## 
## Results are averaged over the levels of: Variety 
## Degrees-of-freedom method: satterthwaite 
## Confidence level used: 0.95</code></pre>
<div id="dfoptions" class="section level6">
<h6></h6>
<!-- @index Degrees of freedom; *z* tests; Asymptotic tests -->
<p>This latest result uses the Satterthwaite method, which is implemented in the <strong>lmerTest</strong> package. Note that, with this method, not only are the degrees of freedom slightly different, but so are the standard errors. That is because the Kenward-Roger method also entails making a bias adjustment to the covariance matrix of the fixed effects; that is the principal difference between the methods. A third possibility is <code>&quot;asymptotic&quot;</code>:</p>
<pre class="r"><code>emmeans(Oats.lmer, &quot;nitro&quot;, lmer.df = &quot;asymptotic&quot;)</code></pre>
<pre class="ro"><code>##  nitro emmean   SE  df asymp.LCL asymp.UCL
##    0.0   78.9 7.28 Inf      64.6      93.2
##    0.2   97.0 7.13 Inf      83.1     111.0
##    0.4  114.2 7.13 Inf     100.2     128.2
##    0.6  124.1 7.07 Inf     110.2     137.9
## 
## Results are averaged over the levels of: Variety 
## Degrees-of-freedom method: asymptotic 
## Confidence level used: 0.95</code></pre>
<p>This just sets all the degrees of freedom to <code>Inf</code> – that’s <strong>emmeans</strong>’s way of using <em>z</em> statistics rather than <em>t</em> statistics. The asymptotic methods tend to make confidence intervals a bit too narrow and P values a bit too low; but they involve much, much less computation. Note that the SEs are the same as obtained using the Satterthwaite method.</p>
<p>Comparisons and contrasts are pretty much the same as with other models. As <code>nitro</code> has quantitative levels, we might want to test polynomial contrasts:</p>
<pre class="r"><code>contrast(Oats.emm.n, &quot;poly&quot;)</code></pre>
<pre class="ro"><code>##  contrast  estimate    SE   df t.ratio p.value
##  linear      152.69 15.58 43.2  9.802  &lt;.0001 
##  quadratic    -8.27  6.95 44.2 -1.190  0.2402 
##  cubic        -6.32 15.21 42.8 -0.415  0.6800 
## 
## Results are averaged over the levels of: Variety 
## Degrees-of-freedom method: kenward-roger</code></pre>
<p>The interesting thing here is that the degrees of freedom are much larger than they are for the EMMs. The reason is because <code>nitro</code> within-plot factor, so inter-plot variations have little role in estimating contrasts among <code>nitro</code> levels. On the other hand, <code>Variety</code> is a whole-plot factor, and there is not much of a bump in degrees of freedom for comparisons:</p>
<pre class="r"><code>emmeans(Oats.lmer, pairwise ~ Variety)</code></pre>
<pre class="ro"><code>## $emmeans
##  Variety     emmean   SE   df lower.CL upper.CL
##  Golden Rain  105.2 7.53 8.46     88.0      122
##  Marvellous   108.5 7.48 8.28     91.3      126
##  Victory       96.9 7.64 8.81     79.6      114
## 
## Results are averaged over the levels of: nitro 
## Degrees-of-freedom method: kenward-roger 
## Confidence level used: 0.95 
## 
## $contrasts
##  contrast                 estimate   SE   df t.ratio p.value
##  Golden Rain - Marvellous    -3.23 6.55 9.56 -0.493  0.8764 
##  Golden Rain - Victory        8.31 6.71 9.80  1.238  0.4595 
##  Marvellous - Victory        11.54 6.67 9.80  1.729  0.2431 
## 
## Results are averaged over the levels of: nitro 
## Degrees-of-freedom method: kenward-roger 
## P value adjustment: tukey method for comparing a family of 3 estimates</code></pre>
</div>
<div id="lmerOpts" class="section level3">
<h3>System options for lmerMod models</h3>
<!-- @index `lmerMod` models!System options for -->
<p>The computation required to compute the adjusted covariance matrix and degrees of freedom may become cumbersome. Some user options (i.e., <code>emm_options()</code> calls) make it possible to streamline these computations through default methods and limitations on them. First, the option <code>lmer.df</code>, which may have values of <code>&quot;kenward-roger&quot;</code>, <code>&quot;satterthwaite&quot;</code>, or <code>&quot;asymptotic&quot;</code> (partial matches are OK!) specifies the default degrees-of-freedom method.</p>
<p>The options <code>disable.pbkrtest</code> and <code>disable.lmerTest</code> may be <code>TRUE</code> or <code>FALSE</code>, and comprise another way of controlling which method is used (e.g., the Kenward-Roger method will not be used if <code>get_emm_option(&quot;disable.pbkrtest&quot;) == TRUE</code>). Finally, the options <code>pbkrtest.limit</code> and <code>lmerTest.limit</code>, which should be set to numeric values, enable the given package conditionally on whether the number of data rows does not exceed the given limit. The factory default is 3000 for both limits.</p>
<p><a href="#contents">Back to Contents</a></p>
</div>
</div>
<div id="offsets" class="section level2">
<h2>Models with offsets</h2>
<!-- @index Offsets; Examples!Insurance claims (SAS); `ref_grid()`!`offset` -->
<p>If a model is fitted and its formula includes an <code>offset()</code> term, then by default, the offset is computed and included in the reference grid. To illustrate, consider a hypothetical dataset on insurance claims (used as an <a href="https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_genmod_sect006.htm">example in SAS’s documentation</a>). There are classes of cars of varying counts (<code>n</code>), sizes (<code>size</code>), and age (<code>age</code>), and we record the number of insurance claims (<code>claims</code>). We fit a Poisson model to <code>claims</code> as a function of <code>size</code> and <code>age</code>. An offset of <code>log(n)</code> is included so that <code>n</code> functions as an “exposure” variable.</p>
<pre class="r"><code>ins &lt;- data.frame(
    n = c(500, 1200, 100, 400, 500, 300),
    size = factor(rep(1:3,2), labels = c(&quot;S&quot;,&quot;M&quot;,&quot;L&quot;)),
    age = factor(rep(1:2, each = 3)),
    claims = c(42, 37, 1, 101, 73, 14))
ins.glm &lt;- glm(claims ~ size + age + offset(log(n)), 
               data = ins, family = &quot;poisson&quot;)</code></pre>
<p>First, let’s look at the reference grid obtained by default:</p>
<pre class="r"><code>ref_grid(ins.glm)</code></pre>
<pre class="ro"><code>## &#39;emmGrid&#39; object with variables:
##     size = S, M, L
##     age = 1, 2
##     n = 500
## Transformation: &quot;log&quot;</code></pre>
<p>Note that <code>n</code> is included in the reference grid and that its average value of 500 is used for all predictions. Thus, if we obtain EMMs for, say, <code>age</code>, these are results are based on a pool of 500 cars:</p>
<pre class="r"><code>emmeans(ins.glm, &quot;size&quot;, type = &quot;response&quot;)</code></pre>
<pre class="ro"><code>##  size rate   SE  df asymp.LCL asymp.UCL
##  S    69.3 6.25 Inf     58.03      82.7
##  M    34.6 3.34 Inf     28.67      41.9
##  L    11.9 3.14 Inf      7.07      19.9
## 
## Results are averaged over the levels of: age 
## Confidence level used: 0.95 
## Intervals are back-transformed from the log scale</code></pre>
<p>However, many users would like to ignore the offset for this kind of model, because then the estimates we obtain are rates per unit value of the (logged) offset. This may be accomplished by specifying an <code>offset</code> parameter in the call:</p>
<pre class="r"><code>emmeans(ins.glm, &quot;size&quot;, type = &quot;response&quot;, offset = 0)</code></pre>
<pre class="ro"><code>##  size   rate      SE  df asymp.LCL asymp.UCL
##  S    0.1385 0.01250 Inf    0.1161    0.1653
##  M    0.0693 0.00669 Inf    0.0573    0.0837
##  L    0.0237 0.00627 Inf    0.0141    0.0398
## 
## Results are averaged over the levels of: age 
## Confidence level used: 0.95 
## Intervals are back-transformed from the log scale</code></pre>
<p>You may verify that the above estimates are 1/500th of the previous ones. You may also verify that the above results are identical to those obtained by setting <code>n</code> equal to 1:</p>
<pre class="r"><code>emmeans(ins.glm, &quot;size&quot;, type = &quot;response&quot;, at = list(n = 1))</code></pre>
<p>However, those who use these types of models will be more comfortable directly setting the offset to zero.</p>
<p>By the way, you may set some other reference value for the rates. For example, if you want estimates of claims per 100 cars, simply use (results not shown):</p>
<pre class="r"><code>emmeans(ins.glm, &quot;size&quot;, type = &quot;response&quot;, offset = log(100))</code></pre>
<p><a href="#contents">Back to Contents</a></p>
</div>
<div id="ordinal" class="section level2">
<h2>Ordinal models</h2>
<!-- @index Ordinal models; Examples!`wine`; Examples!Ordinal model
  Ordinal models!Latent scale -->
<p>Ordinal-response models comprise an example where several options are available for obtaining EMMs. To illustrate, consider the <code>wine</code> data in the <strong>ordinal</strong> package. The response is a rating of bitterness on a five-point scale. we will consider a probit model in two factors during fermentation: <code>temp</code> (temperature) and <code>contact</code> (contact with grape skins), with the judge making the rating as a scale predictor:</p>
<pre class="r"><code>require(&quot;ordinal&quot;)</code></pre>
<pre><code>## Loading required package: ordinal</code></pre>
<pre><code>## 
## Attaching package: &#39;ordinal&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:lme4&#39;:
## 
##     VarCorr, ranef</code></pre>
<pre class="r"><code>wine.clm &lt;- clm(rating ~ temp + contact, scale = ~ judge,
                data = wine, link = &quot;probit&quot;)</code></pre>
<p>(in earlier modeling, we found little interaction between the factors.) Here are the EMMs for each factor using default options:</p>
<pre class="r"><code>emmeans(wine.clm, list(pairwise ~ temp, pairwise ~ contact))</code></pre>
<pre class="ro"><code>## $`emmeans of temp`
##  temp emmean    SE  df asymp.LCL asymp.UCL
##  cold -0.884 0.290 Inf    -1.452    -0.316
##  warm  0.601 0.225 Inf     0.161     1.041
## 
## Results are averaged over the levels of: contact, judge 
## Confidence level used: 0.95 
## 
## $`pairwise differences of temp`
##  contrast    estimate    SE  df z.ratio p.value
##  cold - warm    -1.07 0.422 Inf -2.547  0.0109 
## 
## Results are averaged over the levels of: contact, judge 
## 
## $`emmeans of contact`
##  contact emmean    SE  df asymp.LCL asymp.UCL
##  no      -0.614 0.298 Inf   -1.1990   -0.0297
##  yes      0.332 0.201 Inf   -0.0632    0.7264
## 
## Results are averaged over the levels of: temp, judge 
## Confidence level used: 0.95 
## 
## $`pairwise differences of contact`
##  contrast estimate    SE  df z.ratio p.value
##  no - yes   -0.684 0.304 Inf -2.251  0.0244 
## 
## Results are averaged over the levels of: temp, judge</code></pre>
<p>These results are on the “latent” scale; the idea is that there is a continuous random variable (in this case normal, due to the probit link) having a mean that depends on the predictors; and that the ratings are a discretization of the latent variable based on a fixed set of cut points (which are estimated). In this particular example, we also have a scale model that says that the variance of the latent variable depends on the judges. The latent results are quite a bit like those for measurement data, making them easy to interpret. The only catch is that they are not uniquely defined: we could apply a linear transformation to them, and the same linear transformation to the cut points, and the results would be the same.</p>
<div id="ordlp" class="section level6">
<h6></h6>
<!-- @index Ordinal models!Linear-predictor scale -->
<p>The <code>clm</code> function actually fits the model using an ordinary probit model but with different intercepts for each cut point. We can get detailed information for this model by specifying <code>mode = &quot;linear.predictor&quot;</code>:</p>
<pre class="r"><code>tmp &lt;- ref_grid(wine.clm, mode = &quot;lin&quot;)
tmp</code></pre>
<pre class="ro"><code>## &#39;emmGrid&#39; object with variables:
##     temp = cold, warm
##     contact = no, yes
##     judge = 1, 2, 3, 4, 5, 6, 7, 8, 9
##     cut = multivariate response levels: 1|2, 2|3, 3|4, 4|5
## Transformation: &quot;probit&quot;</code></pre>
<p>Note that this reference grid involves an additional constructed predictor named <code>cut</code> that accounts for the different intercepts in the model. Let’s obtain EMMs for <code>temp</code> on the linear-predictor scale:</p>
<pre class="r"><code>emmeans(tmp, &quot;temp&quot;)</code></pre>
<pre class="ro"><code>##  temp emmean    SE  df asymp.LCL asymp.UCL
##  cold  0.884 0.290 Inf     0.316     1.452
##  warm -0.601 0.225 Inf    -1.041    -0.161
## 
## Results are averaged over the levels of: contact, judge, cut 
## Results are given on the probit (not the response) scale. 
## Confidence level used: 0.95</code></pre>
<p>These are just the negatives of the latent results obtained earlier (the sign is changed to make the comparisons go the right direction). Closely related to this is <code>mode = &quot;cum.prob&quot;</code> and <code>mode = &quot;exc.prob&quot;</code>, which simply transform the linear predictor to cumulative probabilities and exceedance (1 - cumulative) probabilities. These modes give us access to the details of the fitted model but are cumbersome to use for describing results. When they can become useful is when you want to work in terms of a particular cut point. Let’s look at <code>temp</code> again in terms of the probability that the rating will be at least 4:</p>
<pre class="r"><code>emmeans(wine.clm, ~ temp, mode = &quot;exc.prob&quot;, at = list(cut = &quot;3|4&quot;))</code></pre>
<pre class="ro"><code>##  temp exc.prob     SE  df asymp.LCL asymp.UCL
##  cold   0.0748 0.0318 Inf    0.0124     0.137
##  warm   0.4069 0.0706 Inf    0.2686     0.545
## 
## Results are averaged over the levels of: contact, judge 
## Confidence level used: 0.95</code></pre>
</div>
<div id="ordprob" class="section level6">
<h6></h6>
<!-- @index Ordinal models!`prob` and `mean.class` -->
<p>There are yet more modes! With <code>mode = &quot;prob&quot;</code>, we obtain estimates of the probability distribution of each rating. Its reference grid includes a factor with the same name as the model response – in this case <code>rating</code>. We usually want to use that as the primary factor, and the factors of interest as <code>by</code> variables:</p>
<pre class="r"><code>emmeans(wine.clm, ~ rating | temp, mode = &quot;prob&quot;)</code></pre>
<pre class="ro"><code>## temp = cold:
##  rating   prob     SE  df asymp.LCL asymp.UCL
##  1      0.1292 0.0625 Inf   0.00667    0.2518
##  2      0.4877 0.0705 Inf   0.34948    0.6259
##  3      0.3083 0.0594 Inf   0.19186    0.4248
##  4      0.0577 0.0238 Inf   0.01104    0.1043
##  5      0.0171 0.0127 Inf  -0.00768    0.0419
## 
## temp = warm:
##  rating   prob     SE  df asymp.LCL asymp.UCL
##  1      0.0156 0.0129 Inf  -0.00961    0.0408
##  2      0.1473 0.0448 Inf   0.05959    0.2350
##  3      0.4302 0.0627 Inf   0.30723    0.5532
##  4      0.2685 0.0625 Inf   0.14593    0.3910
##  5      0.1384 0.0506 Inf   0.03923    0.2376
## 
## Results are averaged over the levels of: contact, judge 
## Confidence level used: 0.95</code></pre>
<p>Using <code>mode = &quot;mean.class&quot;</code> obtains the average of these probability distributions as probabilities of the integers 1–5:</p>
<pre class="r"><code>emmeans(wine.clm, &quot;temp&quot;, mode = &quot;mean.class&quot;)</code></pre>
<pre class="ro"><code>##  temp mean.class    SE  df asymp.LCL asymp.UCL
##  cold       2.35 0.144 Inf      2.06      2.63
##  warm       3.37 0.146 Inf      3.08      3.65
## 
## Results are averaged over the levels of: contact, judge 
## Confidence level used: 0.95</code></pre>
<p>And there is a mode for the scale model too. In this example, the scale model involves only judges, and that is the only factor in the grid:</p>
<pre class="r"><code>summary(ref_grid(wine.clm, mode = &quot;scale&quot;), type = &quot;response&quot;)</code></pre>
<pre class="ro"><code>##  judge response    SE  df
##  1        1.000 0.000 Inf
##  2        1.043 0.570 Inf
##  3        1.053 0.481 Inf
##  4        0.710 0.336 Inf
##  5        0.663 0.301 Inf
##  6        0.758 0.341 Inf
##  7        1.071 0.586 Inf
##  8        0.241 0.179 Inf
##  9        0.533 0.311 Inf</code></pre>
<p>Judge 8’s ratings don’t vary much, relative to the others. The scale model is in terms of log(SD). Again, these are not uniquely identifiable, and the first level’s estimate is set to log(1) = 0. so, actually, each estimate shown is a comparison with judge 1.</p>
<p><a href="#contents">Back to Contents</a></p>
</div>
</div>
<div id="mcmc" class="section level2">
<h2>Models fitted using MCMC methods</h2>
<!-- @index Bayesian models; Examples!Bayesian model; Examples!`cbpp`
    `rstanarm`; `hpd.summary()`; `summary()`!HPD intervals -->
<p>To illustrate <strong>emmeans</strong>’s support for models fitted using MCMC methods, consider the <code>example_model</code> available in the <strong>rstanarm</strong> package. The example concerns CBPP, a serious disease of cattle in Ethiopia. A generalized linear mixed model was fitted to the data using the code below. (This is a Bayesian equivalent of the frequentist model we considered in the <a href="transformations.html#cbpp">“Transformations” vignette</a>.) We subsequently obtain its reference grid in the usual way. <!--- I'm faking this; I actually saved the ref_grid in a system file ---></p>
<pre class="r"><code>cbpp &lt;- transform(lme4::cbpp, unit = 1:56)
cbpp.rstan &lt;- rstanarm::stan_glmer(
    cbind(incidence, size - incidence) ~ period + (1|herd) + (1|unit),
    data = cbpp, family = binomial,
    chains = 2, cores = 1, seed = 12345, iter = 500)
cbpp.rg &lt;- ref_grid(cbpp.rstan)</code></pre>
<!--- here's the system file with the ref_grid --->
<p>Here is the structure of the reference grid:</p>
<pre class="r"><code>cbpp.rg</code></pre>
<pre class="ro"><code>## &#39;emmGrid&#39; object with variables:
##     period = 1, 2, 3, 4
## Transformation: &quot;logit&quot;</code></pre>
<p>And, again in the usual way, we can obtain EMMs:</p>
<pre class="r"><code>period.emm &lt;- emmeans(cbpp.rg, &quot;period&quot;)
period.emm</code></pre>
<pre class="ro"><code>##  period emmean lower.HPD upper.HPD
##  1       -1.58     -2.28     -1.02
##  2       -2.73     -3.64     -2.04
##  3       -2.88     -3.95     -2.10
##  4       -3.32     -4.37     -2.30
## 
## Point estimate displayed: median 
## Results are given on the logit (not the response) scale. 
## HPD interval probability: 0.95</code></pre>
<p>The summary for EMMs of Bayesian models shows the median of the posterior distribution of each estimate, along with highest posterior density (HPD) intervals. Under the hood, the posterior sample of parameter estimates is used to compute a corresponding sample of posterior EMMs, and it is those that are summarized. (Technical note: the summary is actually rerouted to the <code>hpd.summary()</code> function.</p>
<div id="bayesxtra" class="section level6">
<h6></h6>
<!-- @index `as.mcmc()`; **coda** package; **bayesplot** package; -->
<p>We can access the posterior EMMs via the <code>as.mcmc</code> method for <code>emmGrid</code> objects. This gives us an object of class <code>mcmc</code> (defined in the <strong>coda</strong> package), which can be summarized and explored as we please.</p>
<pre class="r"><code>require(&quot;coda&quot;)</code></pre>
<pre><code>## Loading required package: coda</code></pre>
<pre class="r"><code>summary(as.mcmc(period.emm))</code></pre>
<pre class="ro"><code>## 
## Iterations = 1:250
## Thinning interval = 1 
## Number of chains = 2 
## Sample size per chain = 250 
## 
## 1. Empirical mean and standard deviation for each variable,
##    plus standard error of the mean:
## 
##            Mean     SD Naive SE Time-series SE
## period 1 -1.588 0.3258  0.01457        0.02049
## period 2 -2.730 0.4124  0.01844        0.02091
## period 3 -2.897 0.4608  0.02061        0.02289
## period 4 -3.334 0.5388  0.02410        0.02843
## 
## 2. Quantiles for each variable:
## 
##            2.5%    25%    50%    75%  97.5%
## period 1 -2.275 -1.801 -1.575 -1.354 -1.008
## period 2 -3.576 -2.980 -2.728 -2.455 -1.894
## period 3 -3.901 -3.190 -2.879 -2.593 -2.034
## period 4 -4.437 -3.662 -3.325 -2.974 -2.350</code></pre>
<p>Note that <code>as.mcmc</code> will actually produce an <code>mcmc.list</code> when there is more than one chain present, as in this example. The 2.5th and 97.5th quantiles are similar, but not identical, to the 95% confidence intervals in the frequentist summary.</p>
</div>
<div id="bias-adj-mcmc" class="section level3">
<h3>Bias-adjusted incidence probabilities</h3>
<!-- @index Bias adjustment!in Bayesian models -->
<p>Next, let us consider the back-transformed results. As is discussed with the <a href="transformations.html#cbpp">frequentist model</a>, there are random effects present, and if wee want to think in terms of marginal probabilities across all herds and units, we should correct for bias; and to do that, we need the standard deviations of the random effects. The model object has MCMC results for the random effects of each herd and each unit, but after those, there are also summary results for the posterior SDs of the two random effects. (I used the <code>colnames</code> function to find that they are in the 78th and 79th columns.) <!-- We already read this in earlier, and here's the faked code --></p>
<pre class="r"><code>cbpp.sigma = as.matrix(cbpp.rstan$stanfit)[, 78:79]</code></pre>
<p>Here are the first few:</p>
<pre class="r"><code>head(cbpp.sigma)</code></pre>
<pre class="ro"><code>##           parameters
## iterations Sigma[unit:(Intercept),(Intercept)] Sigma[herd:(Intercept),(Intercept)]
##       [1,]                           0.6215495                         0.258750321
##       [2,]                           0.7772800                         0.003837586
##       [3,]                           0.5659978                         0.109995051
##       [4,]                           0.6534142                         0.064170985
##       [5,]                           1.5199495                         0.096191607
##       [6,]                           0.6722701                         0.183258794</code></pre>
<p>So to obtain bias-adjusted marginal probabilities, obtain the resultant SD and regrid with bias correction:</p>
<pre class="r"><code>totSD &lt;- sqrt(apply(cbpp.sigma^2, 1, sum))
cbpp.rgrd &lt;- regrid(cbpp.rg, bias.adjust = TRUE, sigma = totSD)
summary(cbpp.rgrd)</code></pre>
<pre class="ro"><code>##  period   prob lower.HPD upper.HPD
##  1      0.2191    0.1194     0.367
##  2      0.0878    0.0314     0.184
##  3      0.0752    0.0250     0.147
##  4      0.0510    0.0129     0.117
## 
## Point estimate displayed: median 
## HPD interval probability: 0.95</code></pre>
<p>Here is a plot of the posterior incidence probabilities, back-transformed:</p>
<pre class="r"><code>bayesplot::mcmc_areas(as.mcmc(cbpp.rgrd))</code></pre>
<p><img src="data:image/png;base64,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" width="432" /></p>
<p>… and here are intervals for each period compared with its neighbor:</p>
<pre class="r"><code>contrast(cbpp.rgrd, &quot;consec&quot;, reverse = TRUE)</code></pre>
<pre class="ro"><code>##  contrast estimate lower.HPD upper.HPD
##  1 - 2      0.1277    0.0191     0.254
##  2 - 3      0.0113   -0.0803     0.126
##  3 - 4      0.0243   -0.0655     0.128
## 
## Point estimate displayed: median 
## HPD interval probability: 0.95</code></pre>
<p>The only interval that excludes zero is the one that compares periods 1 and 2.</p>
</div>
<div id="predict-mcmc" class="section level3">
<h3>Bayesian prediction</h3>
<!-- @index Predictions!Bayesian models; 
            Predictions!Posterior predictive distribution -->
<p>To predict from an MCMC model, just specify the <code>likelihood</code> argument in <code>as.mcmc</code>. Doing so causes the function to simulate data from the posterior predictive distribution. For example, if we want to predict the CBPP incidence in future herds of 25 cattle, we can do:</p>
<pre class="r"><code>set.seed(2019.0605)
cbpp.preds &lt;- as.mcmc(cbpp.rgrd, likelihood = &quot;binomial&quot;, trials = 25)
bayesplot::mcmc_hist(cbpp.preds, binwidth = 1)</code></pre>
<p><img src="data:image/png;base64,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" width="432" /></p>
<p><a href="#contents">Back to Contents</a></p>
<p><a href="vignette-topics.html">Index of all vignette topics</a></p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
