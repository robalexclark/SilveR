<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.7">
<title>Sectioning a function</title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.11/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/combine/npm/katex@0.16.21/dist/katex.min.js,npm/katex@0.16.21/dist/contrib/auto-render.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.11/js/render-katex.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
<div class="title"><h1>Sectioning a function</h1></div>
<div class="author"><h2>Søren Højsgaard</h2></div>
</div>
<div class="body">
<div id="TOC">
<ul class="numbered">
<li><a href="#sec:section-a-functions-domain-with-section-fun"><span class="section-number main-number">1</span> Section a functions domain: with <code>section_fun()</code></a></li>
<li><a href="#sec:the-section-fun-function-in-doby"><span class="section-number main-number">2</span> The <code>section_fun</code> function in <code>doBy</code></a></li>
<li><a href="#sec:example-benchmarking"><span class="section-number main-number">3</span> Example: benchmarking</a></li>
</ul>
</div>
<h2 id="sec:section-a-functions-domain-with-section-fun"><span class="section-number main-number">1</span> Section a functions domain: with <code>section_fun()</code></h2>
<p>The function <code>section_fun</code> is used to create a new function that is a section of the original function. The section is defined by fixing some of the arguments of the original function. The new function is defined on the remaining arguments.</p>
<p>For example, let \(f(x,y)=x+y\). Then \(f_x(y)=f(10, y)\) is a
section of \(f\) to be a function of \(y\) alone.</p>
<p>More generally, let \(E\) be a subset of the cartesian product \(X \times Y\) where \(X\)
and \(Y\) are some sets. Consider a function \(f(x,y)\) defined on
\(E\). Then for any \(x \in X\), the section of \(E\) defined by \(x\)
(denoted \(E_x\)) is the set of \(y\)’s in \(Y\) such that \((x, y)\) is in
\(E\), i.e.
$$
E_x = { y \in Y | (x,y) \in E}
$$</p>
<p>Correspondingly, the section of \(f(x,y)\) defined by \(x\) is the
function \(f_x\) defined on \(E_x\) given by \(f_x(y)=f(x,y)\).</p>
<h2 id="sec:the-section-fun-function-in-doby"><span class="section-number main-number">2</span> The <code>section_fun</code> function in <code>doBy</code></h2>
<p>The function <code>section_fun</code> is used to create a new function that is a section of the original function. The section is defined by fixing some of the arguments of the original function. The new function is defined on the remaining arguments.
There are the following approaches:</p>
<ol>
<li>insert the section values as default values in the function definition (default),</li>
<li>insert the section values in the function body,</li>
<li>store the section values in an auxillary environment.</li>
</ol>
<p>Consider this function:</p>
<pre><code class="language-r">fun  &lt;- function(a, b, c=4, d=9){
    a + b + c + d
}
</code></pre>
<pre><code class="language-r">fun_def &lt;- section_fun(fun, list(b=7, d=10))
fun_def
#&gt; function (a, c = 4, b = 7, d = 10) 
#&gt; {
#&gt;     a + b + c + d
#&gt; }
fun_body &lt;- section_fun(fun, list(b=7, d=10), method=&quot;sub&quot;)
fun_body
#&gt; function (a, c = 4) 
#&gt; {
#&gt;     b = 7
#&gt;     d = 10
#&gt;     a + b + c + d
#&gt; }
fun_env &lt;- section_fun(fun, list(b=7, d=10), method = &quot;env&quot;)
fun_env
#&gt; function (a, c = 4) 
#&gt; {
#&gt;     . &lt;- &quot;use get_section(function_name) to see section&quot;
#&gt;     . &lt;- &quot;use get_fun(function_name) to see original function&quot;
#&gt;     args &lt;- arg_getter()
#&gt;     do.call(fun, args)
#&gt; }
#&gt; &lt;environment: 0x5869dd137e08&gt;
</code></pre>
<p>In the last case, we can see the section and the original function definition as:</p>
<pre><code class="language-r">get_section(fun_env) 
#&gt; $b
#&gt; [1] 7
#&gt; 
#&gt; $d
#&gt; [1] 10
## same as: attr(fun_env, &quot;arg_env&quot;)$args 
get_fun(fun_env) 
#&gt; &lt;srcref: file &quot;&quot; chars 1:9 to 3:1&gt;
## same as: environment(fun_env)$fun
</code></pre>
<p>We get:</p>
<pre><code class="language-r">fun(a=10, b=7, c=5, d=10)
#&gt; [1] 32
fun_def(a=10, c=5)
#&gt; [1] 32
fun_body(a=10, c=5)
#&gt; [1] 32
fun_env(a=10, c=5)
#&gt; [1] 32
</code></pre>
<h2 id="sec:example-benchmarking"><span class="section-number main-number">3</span> Example: benchmarking</h2>
<p>Consider a simple task: Creating and inverting Toeplitz matrices for increasing dimensions:</p>
<pre><code class="language-r">n &lt;- 4
toeplitz(1:n)
#&gt;      [,1] [,2] [,3] [,4]
#&gt; [1,]    1    2    3    4
#&gt; [2,]    2    1    2    3
#&gt; [3,]    3    2    1    2
#&gt; [4,]    4    3    2    1
</code></pre>
<p>An implementation is</p>
<pre><code class="language-r">inv_toep &lt;- function(n) {
    solve(toeplitz(1:n))
}
inv_toep(4)
#&gt;      [,1] [,2] [,3] [,4]
#&gt; [1,] -0.4  0.5  0.0  0.1
#&gt; [2,]  0.5 -1.0  0.5  0.0
#&gt; [3,]  0.0  0.5 -1.0  0.5
#&gt; [4,]  0.1  0.0  0.5 -0.4
</code></pre>
<p>We can benchmark timing for different values of \(n\) as</p>
<pre><code class="language-r">library(microbenchmark)
microbenchmark(
    inv_toep(4), inv_toep(8), inv_toep(16),
    inv_toep(32), inv_toep(64),
    times=5
)
#&gt; Unit: microseconds
#&gt;          expr   min    lq  mean median    uq    max neval cld
#&gt;   inv_toep(4)  13.7  14.0  14.5   14.3  15.0   15.4     5   a
#&gt;   inv_toep(8)  16.4  16.6  17.3   16.9  17.9   18.9     5   a
#&gt;  inv_toep(16)  22.9  23.0  26.8   23.8  28.2   35.9     5   a
#&gt;  inv_toep(32)  49.6  50.8 385.9   51.1  52.6 1725.6     5   a
#&gt;  inv_toep(64) 156.5 156.8 162.3  158.9 169.2  170.0     5   a
</code></pre>
<p>However, it is tedious (and hence error prone) to write these function calls.</p>
<p>A programmatic approach using \code{section_fun} is as follows: First create a list of sectioned functions:</p>
<pre><code class="language-r">n.vec  &lt;- c(3, 4, 5)
fun_list &lt;- lapply(n.vec,
                  function(ni){
                      section_fun(inv_toep, list(n=ni))}
                  )
</code></pre>
<p>We can inspect and evaluate each / all functions as:</p>
<pre><code class="language-r">fun_list[[1]]
#&gt; function (n = 3) 
#&gt; {
#&gt;     solve(toeplitz(1:n))
#&gt; }
fun_list[[1]]()
#&gt;        [,1] [,2]   [,3]
#&gt; [1,] -0.375  0.5  0.125
#&gt; [2,]  0.500 -1.0  0.500
#&gt; [3,]  0.125  0.5 -0.375
</code></pre>
<p>To use the list of functions in connection with microbenchmark we bquote all functions using</p>
<pre><code class="language-r">bquote_list &lt;- function(fnlist){
    lapply(fnlist, function(g) {
        bquote(.(g)())
    }
    )
}
</code></pre>
<p>We get:</p>
<pre><code class="language-r">bq_fun_list &lt;- bquote_list(fun_list)
bq_fun_list[[1]]
#&gt; (function (n = 3) 
#&gt; {
#&gt;     solve(toeplitz(1:n))
#&gt; })()
## Evaluate one:
eval(bq_fun_list[[1]])
#&gt;        [,1] [,2]   [,3]
#&gt; [1,] -0.375  0.5  0.125
#&gt; [2,]  0.500 -1.0  0.500
#&gt; [3,]  0.125  0.5 -0.375
## Evaluate all:
## lapply(bq_fun_list, eval)
</code></pre>
<p>To use microbenchmark we must name the elements of the list:</p>
<pre><code class="language-r">names(bq_fun_list) &lt;- n.vec
microbenchmark(
  list  = bq_fun_list,
  times = 5
)
#&gt; Unit: microseconds
#&gt;  expr  min   lq mean median   uq  max neval cld
#&gt;     3 12.9 13.0 26.0   13.2 13.4 77.2     5   a
#&gt;     4 13.5 13.9 16.9   14.0 18.3 24.9     5   a
#&gt;     5 13.7 13.8 14.9   14.7 15.5 17.0     5   a
</code></pre>
<p>Running the code below provides a benchmark of the different ways of sectioning in terms of speed.</p>
<pre><code class="language-r">n.vec  &lt;- seq(20, 80, by=20)
fun_def &lt;- lapply(n.vec,
                  function(ni){
                      section_fun(inv_toep, list(n=ni), method=&quot;def&quot;)}
                  )
fun_body &lt;- lapply(n.vec,
                  function(ni){
                      section_fun(inv_toep, list(n=ni), method=&quot;sub&quot;)}
                  )
fun_env &lt;- lapply(n.vec,
                  function(ni){
                      section_fun(inv_toep, list(n=ni), method=&quot;env&quot;)}
                  )

bq_fun_list &lt;- bquote_list(c(fun_def, fun_body, fun_env))
names(bq_fun_list) &lt;- paste0(rep(c(&quot;def&quot;, &quot;body&quot;, &quot;env&quot;), each=length(n.vec)), rep(n.vec, 3))

mb &lt;- microbenchmark(
  list  = bq_fun_list,
  times = 2
)
</code></pre>
</div>
</body>
</html>
