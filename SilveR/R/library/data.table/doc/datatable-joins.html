<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.7">
<title>Joins in data.table</title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
<div class="title"><h1>Joins in data.table</h1></div>
<div class="date"><h3>2025-07-07</h3></div>
</div>
<div class="body">
<p>In this vignette you will learn how to perform any join operation using resources available in the <code>data.table</code> syntax.</p>
<p>It assumes familiarity with the <code>data.table</code> syntax. If that is not the case, please read the following vignettes:</p>
<ul>
<li><a href="datatable-intro.html"><code>vignette(&quot;datatable-intro&quot;, package=&quot;data.table&quot;)</code></a></li>
<li><a href="datatable-reference-semantics.html"><code>vignette(&quot;datatable-reference-semantics&quot;, package=&quot;data.table&quot;)</code></a></li>
<li><a href="datatable-keys-fast-subset.html"><code>vignette(&quot;datatable-keys-fast-subset&quot;, package=&quot;data.table&quot;)</code></a></li>
</ul>
<hr />
<h2 id="sec:1-defining-example-data">1. Defining example data</h2>
<p>To illustrate how to use the method available with real life examples, letâ€™s simulate a <strong>normalized database</strong> from a little supermarket by performing the following steps:</p>
<ol>
<li>Defining a <code>data.table</code> where each product is represented by a row with some qualities, but leaving one product without <code>id</code> to show how the framework deals with <em><strong>missing values</strong></em>.</li>
</ol>
<pre><code class="language-r">Products = data.table(
  id = c(1:4,
         NA_integer_),
  name = c(&quot;banana&quot;,
           &quot;carrots&quot;,
           &quot;popcorn&quot;,
           &quot;soda&quot;,
           &quot;toothpaste&quot;),
  price = c(0.63,
            0.89,
            2.99,
            1.49,
            2.99),
  unit = c(&quot;unit&quot;,
           &quot;lb&quot;,
           &quot;unit&quot;,
           &quot;ounce&quot;,
           &quot;unit&quot;),
  type = c(rep(&quot;natural&quot;, 2L),
           rep(&quot;processed&quot;, 3L))
)

Products
#       id       name price   unit      type
#    &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt;
# 1:     1     banana  0.63   unit   natural
# 2:     2    carrots  0.89     lb   natural
# 3:     3    popcorn  2.99   unit processed
# 4:     4       soda  1.49  ounce processed
# 5:    NA toothpaste  2.99   unit processed
</code></pre>
<ol start="2">
<li>Defining a <code>data.table</code> showing the proportion of taxes to be applied for processed products based on their units.</li>
</ol>
<pre><code class="language-r">NewTax = data.table(
  unit = c(&quot;unit&quot;,&quot;ounce&quot;),
  type = &quot;processed&quot;,
  tax_prop = c(0.65, 0.20)
)

NewTax
#      unit      type tax_prop
#    &lt;char&gt;    &lt;char&gt;    &lt;num&gt;
# 1:   unit processed     0.65
# 2:  ounce processed     0.20
</code></pre>
<ol start="3">
<li>Defining a <code>data.table</code> simulating the products received every Monday with a <code>product_id</code> that is not present in the <code>Products</code> table.</li>
</ol>
<pre><code class="language-r">set.seed(2156)

ProductReceived = data.table(
  id = 1:10,
  date = seq(from = as.IDate(&quot;2024-01-08&quot;), length.out = 10L, by = &quot;week&quot;),
  product_id = sample(c(NA_integer_, 1:3, 6L), size = 10L, replace = TRUE),
  count = sample(c(50L, 100L, 150L), size = 10L, replace = TRUE)
)

ProductReceived
#        id       date product_id count
#     &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt;
#  1:     1 2024-01-08         NA   150
#  2:     2 2024-01-15          1   100
#  3:     3 2024-01-22          6   100
#  4:     4 2024-01-29          1   150
#  5:     5 2024-02-05          2    50
#  6:     6 2024-02-12          1   150
#  7:     7 2024-02-19          2   150
#  8:     8 2024-02-26          2   100
#  9:     9 2024-03-04          1   100
# 10:    10 2024-03-11          3   150
</code></pre>
<ol start="4">
<li>Defining a <code>data.table</code> to show some sales that can take place on weekdays with another <code>product_id</code> that is not present in the <code>Products</code> table.</li>
</ol>
<pre><code class="language-r">sample_date = function(from, to, size, ...){
  all_days = seq(from = from, to = to, by = &quot;day&quot;)
  weekdays = all_days[wday(all_days) %in% 2:6]
  days_sample = sample(weekdays, size, ...)
  days_sample_desc = sort(days_sample)
  days_sample_desc
}

set.seed(5415)

ProductSales = data.table(
  id = 1:10,
  date = ProductReceived[, sample_date(min(date), max(date), 10L)],
  product_id = sample(c(1:3, 7L), size = 10L, replace = TRUE),
  count = sample(c(50L, 100L, 150L), size = 10L, replace = TRUE)
)


ProductSales
#        id       date product_id count
#     &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt;
#  1:     1 2024-01-08          7    50
#  2:     2 2024-01-11          2   150
#  3:     3 2024-01-18          1    50
#  4:     4 2024-01-25          1   100
#  5:     5 2024-01-26          3   100
#  6:     6 2024-02-02          3   150
#  7:     7 2024-02-06          2   150
#  8:     8 2024-02-15          7   150
#  9:     9 2024-02-27          1   150
# 10:    10 2024-03-08          1    50
</code></pre>
<h2 id="sec:2-data-table-joining-syntax">2. <code>data.table</code> joining syntax</h2>
<p>Before taking advantage of the <code>data.table</code> syntax to perform join operations we need to know which arguments can help us to perform successful joins.</p>
<p>The next diagram shows a description for each basic argument. In the following sections we will show how to use each of them and add more complexity little by little.</p>
<pre><code>x[i, on, nomatch]
| |  |   |
| |  |   \__ If NULL only returns rows linked in x and i tables
| |  \____ a character vector or list defining match logic
| \_____ primary data.table, list or data.frame
\____ secondary data.table
</code></pre>
<blockquote>
<p>Please keep in mind that the standard argument order in <code>data.table</code> is <code>dt[i, j, by]</code>. For join operations, it is recommended to pass the <code>on</code> and <code>nomatch</code> arguments by name to avoid using <code>j</code> and <code>by</code> when they are not needed.</p>
</blockquote>
<h2 id="sec:3-equi-joins">3. Equi joins</h2>
<p>This the most common and simple case as we can find common elements between tables to combine.</p>
<p>The relationship between tables can be:</p>
<ul>
<li><strong>One to one</strong>: When each matching value is unique on each table.</li>
<li><strong>One to many</strong>: When some matching values are repeated in one of the table both unique in the other one.</li>
<li><strong>Many to many</strong>: When the matching values are repeated several times on each table.</li>
</ul>
<p>In most of the following examples we will perform <em>one to many</em> matches, but we are also going to take the time to explain the resources available to perform <em>many to many</em> matches.</p>
<h3 id="sec:3-1-right-join">3.1. Right join</h3>
<p>Use this method if you need to combine columns from 2 tables based on one or more references but <em><strong>keeping all rows present in the table located on the right (in the the square brackets)</strong></em>.</p>
<p>In our supermarket context, we can perform a right join to see more details about the products received as this is relation <em>one to many</em> by passing a vector to the <code>on</code> argument.</p>
<pre><code class="language-r">Products[ProductReceived,
         on = c(id = &quot;product_id&quot;)]
#        id       name price   unit      type  i.id       date count
#     &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt; &lt;int&gt;     &lt;IDat&gt; &lt;int&gt;
#  1:    NA toothpaste  2.99   unit processed     1 2024-01-08   150
#  2:     1     banana  0.63   unit   natural     2 2024-01-15   100
#  3:     6       &lt;NA&gt;    NA   &lt;NA&gt;      &lt;NA&gt;     3 2024-01-22   100
#  4:     1     banana  0.63   unit   natural     4 2024-01-29   150
#  5:     2    carrots  0.89     lb   natural     5 2024-02-05    50
#  6:     1     banana  0.63   unit   natural     6 2024-02-12   150
#  7:     2    carrots  0.89     lb   natural     7 2024-02-19   150
#  8:     2    carrots  0.89     lb   natural     8 2024-02-26   100
#  9:     1     banana  0.63   unit   natural     9 2024-03-04   100
# 10:     3    popcorn  2.99   unit processed    10 2024-03-11   150
</code></pre>
<p>As many things have changed, letâ€™s explain the new characteristics in the following groups:</p>
<ul>
<li>
<p><strong>Column level</strong></p>
<ul>
<li>The <em>first group</em> of columns in the new <code>data.table</code> comes from the <code>x</code> table.</li>
<li>The <em>second group</em> of columns in the new <code>data.table</code> comes from the <code>i</code> table.</li>
<li>If the join operation presents a present any <strong>name conflict</strong> (both table have same column name) the <em><strong>prefix</strong></em> <code>i.</code> is added to column names from the <strong>right-hand table</strong> (table on <code>i</code> position).</li>
</ul>
</li>
<li>
<p><strong>Row level</strong></p>
<ul>
<li>The missing <code>product_id</code> present on the <code>ProductReceived</code> table in row 1 was successfully matched with missing <code>id</code> of the <code>Products</code> table, so <code>NA</code> <em><strong>values are treated as any other value</strong></em>.</li>
<li>All rows from in the <code>i</code> table were kept including:
<ul>
<li>Not matching rows like the one with <code>product_id = 6</code>.</li>
<li>Rows that repeat the same <code>product_id</code> several times.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="sec:3-1-1-joining-by-a-list-argument">3.1.1. Joining by a list argument</h4>
<p>If you are following the vignette, you might have found out that we used a vector to define the relations between tables in the <code>on</code> argument, that is really useful if you are <strong>creating your own functions</strong>, but another alternative is to use a <strong>list</strong> to define the columns to match.</p>
<p>To use this capacity, we have 2 equivalent alternatives:</p>
<ul>
<li>Wrapping the related columns in the base R <code>list</code> function.</li>
</ul>
<pre><code class="language-r">Products[ProductReceived,
         on = list(id = product_id)]
</code></pre>
<ul>
<li>Wrapping the related columns in the <code>data.table</code> <code>list</code> alias <code>.</code>.</li>
</ul>
<pre><code class="language-r">Products[ProductReceived,
         on = .(id = product_id)]
</code></pre>
<h4 id="sec:3-1-2-alternatives-to-define-the-on-argument">3.1.2. Alternatives to define the <code>on</code> argument</h4>
<p>In all the prior example we have pass the column names we want to match to the <code>on</code> argument but <code>data.table</code> also have alternatives to that syntax.</p>
<ul>
<li><strong>Natural join</strong>: Selects the columns to perform the match based on common column names. To illustrate this method, letâ€™s change the column of <code>Products</code> table from <code>id</code> to <code>product_id</code> and use the keyword <code>.NATURAL</code>.</li>
</ul>
<pre><code class="language-r">ProductsChangedName = setnames(copy(Products), &quot;id&quot;, &quot;product_id&quot;)
ProductsChangedName
#    product_id       name price   unit      type
#         &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt;
# 1:          1     banana  0.63   unit   natural
# 2:          2    carrots  0.89     lb   natural
# 3:          3    popcorn  2.99   unit processed
# 4:          4       soda  1.49  ounce processed
# 5:         NA toothpaste  2.99   unit processed

ProductsChangedName[ProductReceived, on = .NATURAL]
#     product_id       name price   unit      type    id       date count
#          &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt; &lt;int&gt;     &lt;IDat&gt; &lt;int&gt;
#  1:         NA toothpaste  2.99   unit processed     1 2024-01-08   150
#  2:          1     banana  0.63   unit   natural     2 2024-01-15   100
#  3:          6       &lt;NA&gt;    NA   &lt;NA&gt;      &lt;NA&gt;     3 2024-01-22   100
#  4:          1     banana  0.63   unit   natural     4 2024-01-29   150
#  5:          2    carrots  0.89     lb   natural     5 2024-02-05    50
#  6:          1     banana  0.63   unit   natural     6 2024-02-12   150
#  7:          2    carrots  0.89     lb   natural     7 2024-02-19   150
#  8:          2    carrots  0.89     lb   natural     8 2024-02-26   100
#  9:          1     banana  0.63   unit   natural     9 2024-03-04   100
# 10:          3    popcorn  2.99   unit processed    10 2024-03-11   150
</code></pre>
<ul>
<li><strong>Keyed join</strong>: Selects the columns to perform the match based on keyed columns regardless of their names.To illustrate this method, we need to define keys in the same order for both tables.</li>
</ul>
<pre><code class="language-r">ProductsKeyed = setkey(copy(Products), id)
key(ProductsKeyed)
# [1] &quot;id&quot;

ProductReceivedKeyed = setkey(copy(ProductReceived), product_id)
key(ProductReceivedKeyed)
# [1] &quot;product_id&quot;

ProductsKeyed[ProductReceivedKeyed]
# Key: &lt;id&gt;
#        id       name price   unit      type  i.id       date count
#     &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt; &lt;int&gt;     &lt;IDat&gt; &lt;int&gt;
#  1:    NA toothpaste  2.99   unit processed     1 2024-01-08   150
#  2:     1     banana  0.63   unit   natural     2 2024-01-15   100
#  3:     1     banana  0.63   unit   natural     4 2024-01-29   150
#  4:     1     banana  0.63   unit   natural     6 2024-02-12   150
#  5:     1     banana  0.63   unit   natural     9 2024-03-04   100
#  6:     2    carrots  0.89     lb   natural     5 2024-02-05    50
#  7:     2    carrots  0.89     lb   natural     7 2024-02-19   150
#  8:     2    carrots  0.89     lb   natural     8 2024-02-26   100
#  9:     3    popcorn  2.99   unit processed    10 2024-03-11   150
# 10:     6       &lt;NA&gt;    NA   &lt;NA&gt;      &lt;NA&gt;     3 2024-01-22   100
</code></pre>
<h4 id="sec:3-1-3-operations-after-joining">3.1.3. Operations after joining</h4>
<p>Most of the time after a join is complete we need to make some additional transformations. To make so we have the following alternatives:</p>
<ul>
<li>Chaining a new instruction by adding a pair of brakes <code>[]</code>.</li>
<li>Passing a list with the columns that we want to keep or create to the <code>j</code> argument.</li>
</ul>
<p>Our recommendation is to use the second alternative if possible, as it is <strong>faster</strong> and uses <strong>less memory</strong> than the first one.</p>
<h5 id="sec:managing-shared-column-names-with-the-j-argument">Managing shared column Names with the j argument</h5>
<p>The <code>j</code> argument has great alternatives to manage joins with tables <strong>sharing the same names for several columns</strong>. By default all columns are taking their source from the the <code>x</code> table, but we can also use the <code>x.</code> prefix to make clear the source and use the prefix <code>i.</code> to use any column form the table declared in the <code>i</code> argument of the <code>x</code> table.</p>
<p>Going back to the little supermarket, after updating the <code>ProductReceived</code> table with the <code>Products</code> table, it seems convenient apply the following changes:</p>
<ul>
<li>Changing the columns names from <code>id</code> to <code>product_id</code> and from <code>i.id</code> to <code>received_id</code>.</li>
<li>Adding the <code>total_value</code>.</li>
</ul>
<pre><code class="language-r">Products[
  ProductReceived,
  on = c(&quot;id&quot; = &quot;product_id&quot;),
  j = .(product_id = x.id,
        name = x.name,
        price,
        received_id = i.id,
        date = i.date,
        count,
        total_value = price * count)
]
#     product_id       name price received_id       date count total_value
#          &lt;int&gt;     &lt;char&gt; &lt;num&gt;       &lt;int&gt;     &lt;IDat&gt; &lt;int&gt;       &lt;num&gt;
#  1:         NA toothpaste  2.99           1 2024-01-08   150       448.5
#  2:          1     banana  0.63           2 2024-01-15   100        63.0
#  3:         NA       &lt;NA&gt;    NA           3 2024-01-22   100          NA
#  4:          1     banana  0.63           4 2024-01-29   150        94.5
#  5:          2    carrots  0.89           5 2024-02-05    50        44.5
#  6:          1     banana  0.63           6 2024-02-12   150        94.5
#  7:          2    carrots  0.89           7 2024-02-19   150       133.5
#  8:          2    carrots  0.89           8 2024-02-26   100        89.0
#  9:          1     banana  0.63           9 2024-03-04   100        63.0
# 10:          3    popcorn  2.99          10 2024-03-11   150       448.5
</code></pre>
<h5 id="sec:summarizing-with-on-in-data-table">Summarizing with <code>on</code> in <code>data.table</code></h5>
<p>We can also use this alternative to return aggregated results based columns present in the <code>x</code> table.</p>
<p>For example, we might interested in how much money we expend buying products each date regardless the products.</p>
<pre><code class="language-r">dt1 = ProductReceived[
  Products,
  on = c(&quot;product_id&quot; = &quot;id&quot;),
  by = .EACHI,
  j = .(total_value_received  = sum(price * count))
]


dt2 = ProductReceived[
  Products,
  on = c(&quot;product_id&quot; = &quot;id&quot;),
][, .(total_value_received  = sum(price * count)),
  by = &quot;product_id&quot;
]

identical(dt1, dt2)
# [1] TRUE
</code></pre>
<h4 id="sec:3-1-4-joining-based-on-several-columns">3.1.4. Joining based on several columns</h4>
<p>So far we have just joined <code>data.table</code> base on 1 column, but itâ€™s important to know that the package can join tables matching several columns.</p>
<p>To illustrate this, letâ€™s assume that we want to add the <code>tax_prop</code> from <code>NewTax</code> to <strong>update</strong> the <code>Products</code> table.</p>
<pre><code class="language-r">NewTax[Products, on = c(&quot;unit&quot;, &quot;type&quot;)]
#      unit      type tax_prop    id       name price
#    &lt;char&gt;    &lt;char&gt;    &lt;num&gt; &lt;int&gt;     &lt;char&gt; &lt;num&gt;
# 1:   unit   natural       NA     1     banana  0.63
# 2:     lb   natural       NA     2    carrots  0.89
# 3:   unit processed     0.65     3    popcorn  2.99
# 4:  ounce processed     0.20     4       soda  1.49
# 5:   unit processed     0.65    NA toothpaste  2.99
</code></pre>
<h3 id="sec:3-2-inner-join">3.2. Inner join</h3>
<p>Use this method if you need to combine columns from 2 tables based on one or more references but <em><strong>keeping only rows matched in both tables</strong></em>.</p>
<p>To perform this operation we just need to add <code>nomatch = NULL</code> or <code>nomatch = 0</code> to any of the prior join operations to return the same results.</p>
<pre><code class="language-r"># First Table
Products[ProductReceived,
         on = c(&quot;id&quot; = &quot;product_id&quot;),
         nomatch = NULL]
#       id       name price   unit      type  i.id       date count
#    &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt; &lt;int&gt;     &lt;IDat&gt; &lt;int&gt;
# 1:    NA toothpaste  2.99   unit processed     1 2024-01-08   150
# 2:     1     banana  0.63   unit   natural     2 2024-01-15   100
# 3:     1     banana  0.63   unit   natural     4 2024-01-29   150
# 4:     2    carrots  0.89     lb   natural     5 2024-02-05    50
# 5:     1     banana  0.63   unit   natural     6 2024-02-12   150
# 6:     2    carrots  0.89     lb   natural     7 2024-02-19   150
# 7:     2    carrots  0.89     lb   natural     8 2024-02-26   100
# 8:     1     banana  0.63   unit   natural     9 2024-03-04   100
# 9:     3    popcorn  2.99   unit processed    10 2024-03-11   150

# Second Table
ProductReceived[Products,
                on = .(product_id = id),
                nomatch = NULL]
#       id       date product_id count       name price   unit      type
#    &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt;
# 1:     2 2024-01-15          1   100     banana  0.63   unit   natural
# 2:     4 2024-01-29          1   150     banana  0.63   unit   natural
# 3:     6 2024-02-12          1   150     banana  0.63   unit   natural
# 4:     9 2024-03-04          1   100     banana  0.63   unit   natural
# 5:     5 2024-02-05          2    50    carrots  0.89     lb   natural
# 6:     7 2024-02-19          2   150    carrots  0.89     lb   natural
# 7:     8 2024-02-26          2   100    carrots  0.89     lb   natural
# 8:    10 2024-03-11          3   150    popcorn  2.99   unit processed
# 9:     1 2024-01-08         NA   150 toothpaste  2.99   unit processed
</code></pre>
<p>Despite both tables having the same information, there are some relevant differences:</p>
<ul>
<li>They present different column ordering.</li>
<li>They have column name differences:
<ul>
<li>The <code>id</code> column in the first table has the same information as the <code>product_id</code> in the second table.</li>
<li>The <code>i.id</code> column in the first table has the same information as the <code>id</code> in the second table.</li>
</ul>
</li>
</ul>
<h3 id="sec:3-3-not-join">3.3. Not join</h3>
<p>This method <strong>keeps only the rows that donâ€™t match with any row of a second table</strong>.</p>
<p>To apply this technique we can negate (<code>!</code>) the table located on the <code>i</code> argument.</p>
<pre><code class="language-r">Products[!ProductReceived,
         on = c(&quot;id&quot; = &quot;product_id&quot;)]
#       id   name price   unit      type
#    &lt;int&gt; &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt;
# 1:     4   soda  1.49  ounce processed
</code></pre>
<p>As you can see, the result only has â€˜sodaâ€™, as it was the only product that is not present in the <code>ProductReceived</code> table.</p>
<pre><code class="language-r">ProductReceived[!Products,
                on = c(&quot;product_id&quot; = &quot;id&quot;)]
#       id       date product_id count
#    &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt;
# 1:     3 2024-01-22          6   100
</code></pre>
<p>In this case, the operation returns the row with <code>product_id = 6,</code> as it is not present on the <code>Products</code> table.</p>
<h3 id="sec:3-4-semi-join">3.4. Semi join</h3>
<p>This method extracts <strong>only the rows that match any row in a second table</strong>, without combining the columns of the tables.</p>
<p>Itâ€™s very similar to subset as join, but as in this time we are passing a complete table to the <code>i</code> we need to ensure that:</p>
<ul>
<li>
<p>Any row in the <code>x</code> table is duplicated due row duplication in the table passed to the <code>i</code> argument.</p>
</li>
<li>
<p>All the renaming rows from <code>x</code> should keep the original row order.</p>
</li>
</ul>
<p>To make this, you can apply the following steps:</p>
<ol>
<li>Perform a <strong>inner join</strong> with <code>which = TRUE</code> to save the row numbers related to each matching row of the <code>x</code> table.</li>
</ol>
<pre><code class="language-r">SubSetRows = Products[
  ProductReceived,
  on = .(id = product_id),
  nomatch = NULL,
  which = TRUE
]

SubSetRows
# [1] 5 1 1 2 1 2 2 1 3
</code></pre>
<ol start="2">
<li>Select and sort the unique rows ids.</li>
</ol>
<pre><code class="language-r">SubSetRowsSorted = sort(unique(SubSetRows))

SubSetRowsSorted
# [1] 1 2 3 5
</code></pre>
<ol start="3">
<li>Selecting the <code>x</code> rows to keep.</li>
</ol>
<pre><code class="language-r">Products[SubSetRowsSorted]
#       id       name price   unit      type
#    &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt;
# 1:     1     banana  0.63   unit   natural
# 2:     2    carrots  0.89     lb   natural
# 3:     3    popcorn  2.99   unit processed
# 4:    NA toothpaste  2.99   unit processed
</code></pre>
<h3 id="sec:3-5-left-join">3.5. Left join</h3>
<p>Use this method if you need to combine columns from 2 tables based on one or more references but <em><strong>keeping all rows present in the table located on the left</strong></em>.</p>
<p>To perform this operation, we just need to <strong>exchange the order between both tables</strong> and the columns names in the <code>on</code> argument.</p>
<pre><code class="language-r">ProductReceived[Products,
                on = list(product_id = id)]
#        id       date product_id count       name price   unit      type
#     &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt;
#  1:     2 2024-01-15          1   100     banana  0.63   unit   natural
#  2:     4 2024-01-29          1   150     banana  0.63   unit   natural
#  3:     6 2024-02-12          1   150     banana  0.63   unit   natural
#  4:     9 2024-03-04          1   100     banana  0.63   unit   natural
#  5:     5 2024-02-05          2    50    carrots  0.89     lb   natural
#  6:     7 2024-02-19          2   150    carrots  0.89     lb   natural
#  7:     8 2024-02-26          2   100    carrots  0.89     lb   natural
#  8:    10 2024-03-11          3   150    popcorn  2.99   unit processed
#  9:    NA       &lt;NA&gt;          4    NA       soda  1.49  ounce processed
# 10:     1 2024-01-08         NA   150 toothpaste  2.99   unit processed
</code></pre>
<p>Here some important considerations:</p>
<ul>
<li>
<p><strong>Column level</strong></p>
<ul>
<li>The <em>first group</em> of columns now comes from the <code>ProductReceived</code> table as it is the <code>x</code> table.</li>
<li>The <em>second group</em> of columns now comes from the <code>Products</code> table as it is the <code>i</code> table.</li>
<li>It didnâ€™t add the prefix <code>i.</code> to any column.</li>
</ul>
</li>
<li>
<p><strong>Row level</strong></p>
<ul>
<li>All rows from the <code>i</code> table were kept: the soda entry from <code>Products</code> that was not matched by any row in <code>ProductReceived</code> is still part of the results.</li>
<li>The row related to <code>product_id = 6</code> is not part of the results any more as it is not present in the <code>Products</code> table.</li>
</ul>
</li>
</ul>
<h4 id="sec:3-5-1-joining-after-chain-operations">3.5.1. Joining after chain operations</h4>
<p>One of the key features of <code>data.table</code> is that we can apply several operations before saving our final results by chaining brackets.</p>
<pre><code class="language-r">DT[
  ...
][
  ...
][
  ...
]
</code></pre>
<p>So far, if after applying all that operations <strong>we want to join new columns without removing any row</strong>, we would need to stop the chaining process, save a temporary table and later apply the join operation.</p>
<p>To avoid that situation, we can use special symbols <code>.SD</code>, to apply a <strong>right join based on the changed table</strong>.</p>
<pre><code class="language-r">NewTax[Products,
       on = c(&quot;unit&quot;, &quot;type&quot;)
][, ProductReceived[.SD,
                    on = list(product_id = id)],
  .SDcols = !c(&quot;unit&quot;, &quot;type&quot;)]
#        id       date product_id count tax_prop       name price
#     &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt;    &lt;num&gt;     &lt;char&gt; &lt;num&gt;
#  1:     2 2024-01-15          1   100       NA     banana  0.63
#  2:     4 2024-01-29          1   150       NA     banana  0.63
#  3:     6 2024-02-12          1   150       NA     banana  0.63
#  4:     9 2024-03-04          1   100       NA     banana  0.63
#  5:     5 2024-02-05          2    50       NA    carrots  0.89
#  6:     7 2024-02-19          2   150       NA    carrots  0.89
#  7:     8 2024-02-26          2   100       NA    carrots  0.89
#  8:    10 2024-03-11          3   150     0.65    popcorn  2.99
#  9:    NA       &lt;NA&gt;          4    NA     0.20       soda  1.49
# 10:     1 2024-01-08         NA   150     0.65 toothpaste  2.99
</code></pre>
<h3 id="sec:3-6-many-to-many-join">3.6. Many to many join</h3>
<p>Sometimes we want to join tables based on columns with <strong>duplicated <code>id</code> values</strong> to later perform some transformations later.</p>
<p>To illustrate this situation letâ€™s take as an example the <code>product_id == 1L</code>, which have 4 rows in our <code>ProductReceived</code> table.</p>
<pre><code class="language-r">ProductReceived[product_id == 1L]
#       id       date product_id count
#    &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt;
# 1:     2 2024-01-15          1   100
# 2:     4 2024-01-29          1   150
# 3:     6 2024-02-12          1   150
# 4:     9 2024-03-04          1   100
</code></pre>
<p>And 4 rows in our <code>ProductSales</code> table.</p>
<pre><code class="language-r">ProductSales[product_id == 1L]
#       id       date product_id count
#    &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt;
# 1:     3 2024-01-18          1    50
# 2:     4 2024-01-25          1   100
# 3:     9 2024-02-27          1   150
# 4:    10 2024-03-08          1    50
</code></pre>
<p>To perform this join we just need to filter <code>product_id == 1L</code> in the <code>i</code> table to limit the join just to that product and set the argument <code>allow.cartesian = TRUE</code> to allow combining each row from one table with every row from the other table.</p>
<pre><code class="language-r">ProductReceived[ProductSales[list(1L),
                             on = &quot;product_id&quot;,
                             nomatch = NULL],
                on = &quot;product_id&quot;,
                allow.cartesian = TRUE]
#        id       date product_id count  i.id     i.date i.count
#     &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;IDat&gt;   &lt;int&gt;
#  1:     2 2024-01-15          1   100     3 2024-01-18      50
#  2:     4 2024-01-29          1   150     3 2024-01-18      50
#  3:     6 2024-02-12          1   150     3 2024-01-18      50
#  4:     9 2024-03-04          1   100     3 2024-01-18      50
#  5:     2 2024-01-15          1   100     4 2024-01-25     100
#  6:     4 2024-01-29          1   150     4 2024-01-25     100
#  7:     6 2024-02-12          1   150     4 2024-01-25     100
#  8:     9 2024-03-04          1   100     4 2024-01-25     100
#  9:     2 2024-01-15          1   100     9 2024-02-27     150
# 10:     4 2024-01-29          1   150     9 2024-02-27     150
# 11:     6 2024-02-12          1   150     9 2024-02-27     150
# 12:     9 2024-03-04          1   100     9 2024-02-27     150
# 13:     2 2024-01-15          1   100    10 2024-03-08      50
# 14:     4 2024-01-29          1   150    10 2024-03-08      50
# 15:     6 2024-02-12          1   150    10 2024-03-08      50
# 16:     9 2024-03-04          1   100    10 2024-03-08      50
</code></pre>
<p>Once we understand the result, we can apply the same process for <strong>all products</strong>.</p>
<pre><code class="language-r">ProductReceived[ProductSales,
                on = &quot;product_id&quot;,
                allow.cartesian = TRUE]
#        id       date product_id count  i.id     i.date i.count
#     &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;IDat&gt;   &lt;int&gt;
#  1:    NA       &lt;NA&gt;          7    NA     1 2024-01-08      50
#  2:     5 2024-02-05          2    50     2 2024-01-11     150
#  3:     7 2024-02-19          2   150     2 2024-01-11     150
#  4:     8 2024-02-26          2   100     2 2024-01-11     150
#  5:     2 2024-01-15          1   100     3 2024-01-18      50
#  6:     4 2024-01-29          1   150     3 2024-01-18      50
#  7:     6 2024-02-12          1   150     3 2024-01-18      50
#  8:     9 2024-03-04          1   100     3 2024-01-18      50
#  9:     2 2024-01-15          1   100     4 2024-01-25     100
# 10:     4 2024-01-29          1   150     4 2024-01-25     100
# 11:     6 2024-02-12          1   150     4 2024-01-25     100
# 12:     9 2024-03-04          1   100     4 2024-01-25     100
# 13:    10 2024-03-11          3   150     5 2024-01-26     100
# 14:    10 2024-03-11          3   150     6 2024-02-02     150
# 15:     5 2024-02-05          2    50     7 2024-02-06     150
# 16:     7 2024-02-19          2   150     7 2024-02-06     150
# 17:     8 2024-02-26          2   100     7 2024-02-06     150
# 18:    NA       &lt;NA&gt;          7    NA     8 2024-02-15     150
# 19:     2 2024-01-15          1   100     9 2024-02-27     150
# 20:     4 2024-01-29          1   150     9 2024-02-27     150
# 21:     6 2024-02-12          1   150     9 2024-02-27     150
# 22:     9 2024-03-04          1   100     9 2024-02-27     150
# 23:     2 2024-01-15          1   100    10 2024-03-08      50
# 24:     4 2024-01-29          1   150    10 2024-03-08      50
# 25:     6 2024-02-12          1   150    10 2024-03-08      50
# 26:     9 2024-03-04          1   100    10 2024-03-08      50
#        id       date product_id count  i.id     i.date i.count
</code></pre>
<blockquote>
<p><code>allow.cartesian</code> is defaulted to FALSE as this is seldom what the user wants, and such a cross join can lead to a very large number of rows in the result. For example, if Table A has 100 rows and Table B has 50 rows, their Cartesian product would result in 5000 rows (100 * 50). This can quickly become memory-intensive for large datasets.</p>
</blockquote>
<h4 id="sec:3-6-1-selecting-one-match">3.6.1. Selecting one match</h4>
<p>After joining the table we might find out that we just need to return a single join to extract the information we need. In this case we have 2 alternatives:</p>
<ul>
<li>We can select the <strong>first match</strong>, represented in the next example by <code>id = 2</code>.</li>
</ul>
<pre><code class="language-r">ProductReceived[ProductSales[product_id == 1L],
                on = .(product_id),
                allow.cartesian = TRUE,
                mult = &quot;first&quot;]
#       id       date product_id count  i.id     i.date i.count
#    &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;IDat&gt;   &lt;int&gt;
# 1:     2 2024-01-15          1   100     3 2024-01-18      50
# 2:     2 2024-01-15          1   100     4 2024-01-25     100
# 3:     2 2024-01-15          1   100     9 2024-02-27     150
# 4:     2 2024-01-15          1   100    10 2024-03-08      50
</code></pre>
<ul>
<li>We can select the <strong>last match</strong>, represented in the next example by <code>id = 9</code>.</li>
</ul>
<pre><code class="language-r">ProductReceived[ProductSales[product_id == 1L],
                on = .(product_id),
                allow.cartesian = TRUE,
                mult = &quot;last&quot;]
#       id       date product_id count  i.id     i.date i.count
#    &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;IDat&gt;   &lt;int&gt;
# 1:     9 2024-03-04          1   100     3 2024-01-18      50
# 2:     9 2024-03-04          1   100     4 2024-01-25     100
# 3:     9 2024-03-04          1   100     9 2024-02-27     150
# 4:     9 2024-03-04          1   100    10 2024-03-08      50
</code></pre>
<h4 id="sec:3-6-2-cross-join">3.6.2. Cross join</h4>
<p>If you want to get <strong>all possible row combinations</strong> regardless of any particular id column we can follow the next process:</p>
<ol>
<li>Create a new column in both tables with a constant.</li>
</ol>
<pre><code class="language-r">ProductsTempId = copy(Products)[, temp_id := 1L]
</code></pre>
<ol start="2">
<li>Join both table based on the new column and remove it after ending the process, as it doesnâ€™t have reason to stay after joining.</li>
</ol>
<pre><code class="language-r">AllProductsMix =
  ProductsTempId[ProductsTempId,
                 on = &quot;temp_id&quot;,
                 allow.cartesian = TRUE]

AllProductsMix[, temp_id := NULL]

# Removing type to make easier to see the result when printing the table
AllProductsMix[, !c(&quot;type&quot;, &quot;i.type&quot;)]
#        id       name price   unit  i.id     i.name i.price i.unit
#     &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt; &lt;int&gt;     &lt;char&gt;   &lt;num&gt; &lt;char&gt;
#  1:     1     banana  0.63   unit     1     banana    0.63   unit
#  2:     2    carrots  0.89     lb     1     banana    0.63   unit
#  3:     3    popcorn  2.99   unit     1     banana    0.63   unit
#  4:     4       soda  1.49  ounce     1     banana    0.63   unit
#  5:    NA toothpaste  2.99   unit     1     banana    0.63   unit
#  6:     1     banana  0.63   unit     2    carrots    0.89     lb
#  7:     2    carrots  0.89     lb     2    carrots    0.89     lb
#  8:     3    popcorn  2.99   unit     2    carrots    0.89     lb
#  9:     4       soda  1.49  ounce     2    carrots    0.89     lb
# 10:    NA toothpaste  2.99   unit     2    carrots    0.89     lb
# 11:     1     banana  0.63   unit     3    popcorn    2.99   unit
# 12:     2    carrots  0.89     lb     3    popcorn    2.99   unit
# 13:     3    popcorn  2.99   unit     3    popcorn    2.99   unit
# 14:     4       soda  1.49  ounce     3    popcorn    2.99   unit
# 15:    NA toothpaste  2.99   unit     3    popcorn    2.99   unit
# 16:     1     banana  0.63   unit     4       soda    1.49  ounce
# 17:     2    carrots  0.89     lb     4       soda    1.49  ounce
# 18:     3    popcorn  2.99   unit     4       soda    1.49  ounce
# 19:     4       soda  1.49  ounce     4       soda    1.49  ounce
# 20:    NA toothpaste  2.99   unit     4       soda    1.49  ounce
# 21:     1     banana  0.63   unit    NA toothpaste    2.99   unit
# 22:     2    carrots  0.89     lb    NA toothpaste    2.99   unit
# 23:     3    popcorn  2.99   unit    NA toothpaste    2.99   unit
# 24:     4       soda  1.49  ounce    NA toothpaste    2.99   unit
# 25:    NA toothpaste  2.99   unit    NA toothpaste    2.99   unit
#        id       name price   unit  i.id     i.name i.price i.unit
</code></pre>
<h3 id="sec:3-7-full-join">3.7. Full join</h3>
<p>Use this method if you need to combine columns from 2 tables based on one or more references <em><strong>without removing any row</strong></em>.</p>
<p>As we saw in the previous section, any of the prior operations can keep the missing <code>product_id = 6</code> and the <strong>soda</strong> (<code>product_id = 4</code>) as part of the results.</p>
<p>To save this problem, we can use the <code>merge</code> function even though it is lower than using the native <code>data.table</code>â€™s joining syntax.</p>
<pre><code class="language-r">merge(x = Products,
      y = ProductReceived,
      by.x = &quot;id&quot;,
      by.y = &quot;product_id&quot;,
      all = TRUE,
      sort = FALSE)
#        id       name price   unit      type  id.y       date count
#     &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt; &lt;int&gt;     &lt;IDat&gt; &lt;int&gt;
#  1:     1     banana  0.63   unit   natural     2 2024-01-15   100
#  2:     1     banana  0.63   unit   natural     4 2024-01-29   150
#  3:     1     banana  0.63   unit   natural     6 2024-02-12   150
#  4:     1     banana  0.63   unit   natural     9 2024-03-04   100
#  5:     2    carrots  0.89     lb   natural     5 2024-02-05    50
#  6:     2    carrots  0.89     lb   natural     7 2024-02-19   150
#  7:     2    carrots  0.89     lb   natural     8 2024-02-26   100
#  8:     3    popcorn  2.99   unit processed    10 2024-03-11   150
#  9:     4       soda  1.49  ounce processed    NA       &lt;NA&gt;    NA
# 10:    NA toothpaste  2.99   unit processed     1 2024-01-08   150
# 11:     6       &lt;NA&gt;    NA   &lt;NA&gt;      &lt;NA&gt;     3 2024-01-22   100
</code></pre>
<h2 id="sec:4-non-equi-join">4. Non-equi join</h2>
<p>A non-equi join is a type of join where the condition for matching rows is based on comparison operators other than equality, such as <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, or <code>&gt;=</code>. This allows for <strong>more flexible joining criteria</strong>. In <code>data.table</code>, non-equi joins are particularly useful for operations like:</p>
<ul>
<li>Finding the nearest match.</li>
<li>Comparing ranges of values between tables.</li>
</ul>
<p>It is a great alternative when, after applying a right or inner join, you:</p>
<ul>
<li>Want to reduce the number of returned rows based on comparisons of numeric columns between tables.</li>
<li>Do not need to retain the columns from table x <em>(the secondary <code>data.table</code>)</em> in the final result.</li>
</ul>
<p>To illustrate how this works, letâ€™s focus on the sales and receives for product 2.</p>
<pre><code class="language-r">ProductSalesProd2 = ProductSales[product_id == 2L]
ProductReceivedProd2 = ProductReceived[product_id == 2L]
</code></pre>
<p>If want to know, for example, you can find any receive that took place before a sales date, we can apply the following.</p>
<pre><code class="language-r">ProductReceivedProd2[ProductSalesProd2,
                     on = &quot;product_id&quot;,
                     allow.cartesian = TRUE
][date &lt; i.date]
#       id       date product_id count  i.id     i.date i.count
#    &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;IDat&gt;   &lt;int&gt;
# 1:     5 2024-02-05          2    50     7 2024-02-06     150
</code></pre>
<p>What does happen if we just apply the same logic on the list passed to <code>on</code>?</p>
<ul>
<li>
<p>As this operation is still a right join, it returns all rows from the <code>i</code> table, but only shows the values for <code>id</code> and <code>count</code> when the rules are met.</p>
</li>
<li>
<p>The date related <code>ProductReceivedProd2</code> was omitted from this new table.</p>
</li>
</ul>
<pre><code class="language-r">ProductReceivedProd2[ProductSalesProd2,
                     on = list(product_id, date &lt; date)]
#       id       date product_id count  i.id i.count
#    &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
# 1:    NA 2024-01-11          2    NA     2     150
# 2:     5 2024-02-06          2    50     7     150
</code></pre>
<p>Now, after applying the join, we can limit the results only showing the cases that meet all joining criteria.</p>
<pre><code class="language-r">ProductReceivedProd2[ProductSalesProd2,
                     on = list(product_id, date &lt; date),
                     nomatch = NULL]
#       id       date product_id count  i.id i.count
#    &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
# 1:     5 2024-02-06          2    50     7     150
</code></pre>
<h2 id="sec:5-rolling-join">5. Rolling join</h2>
<p>Rolling joins are particularly useful in time-series data analysis. They allow you to <strong>match rows based on the nearest value</strong> in a sorted column, typically a date or time column.</p>
<p>This is valuable when you need to align data from different sources <strong>that may not have exact matching timestamps</strong>, or when you want to carry forward the most recent value.</p>
<p>For example, in financial data, you might use a rolling join to assign the most recent stock price to each transaction, even if the price updates and transactions donâ€™t occur at the exact same times.</p>
<p>In our supermarket example, we can use a rolling join to match sales with the most recent product information.</p>
<p>Letâ€™s assume that the price for Bananas and Carrots changes at the first date of each month.</p>
<pre><code class="language-r">ProductPriceHistory = data.table(
  product_id = rep(1:2, each = 3),
  date = rep(as.IDate(c(&quot;2024-01-01&quot;, &quot;2024-02-01&quot;, &quot;2024-03-01&quot;)), 2),
  price = c(0.59, 0.63, 0.65,  # Banana prices
            0.79, 0.89, 0.99)  # Carrot prices
)

ProductPriceHistory
#    product_id       date price
#         &lt;int&gt;     &lt;IDat&gt; &lt;num&gt;
# 1:          1 2024-01-01  0.59
# 2:          1 2024-02-01  0.63
# 3:          1 2024-03-01  0.65
# 4:          2 2024-01-01  0.79
# 5:          2 2024-02-01  0.89
# 6:          2 2024-03-01  0.99
</code></pre>
<p>Now, we can perform a right join giving a different price for each product based on the sale date.</p>
<pre><code class="language-r">ProductPriceHistory[ProductSales,
                    on = .(product_id, date),
                    roll = TRUE,
                    j = .(product_id, date, count, price)]
#     product_id       date count price
#          &lt;int&gt;     &lt;IDat&gt; &lt;int&gt; &lt;num&gt;
#  1:          7 2024-01-08    50    NA
#  2:          2 2024-01-11   150  0.79
#  3:          1 2024-01-18    50  0.59
#  4:          1 2024-01-25   100  0.59
#  5:          3 2024-01-26   100    NA
#  6:          3 2024-02-02   150    NA
#  7:          2 2024-02-06   150  0.89
#  8:          7 2024-02-15   150    NA
#  9:          1 2024-02-27   150  0.63
# 10:          1 2024-03-08    50  0.65
</code></pre>
<p>If we just want to see the matching cases we just need to add the argument <code>nomatch = NULL</code> to perform an inner rolling join.</p>
<pre><code class="language-r">ProductPriceHistory[ProductSales,
                    on = .(product_id, date),
                    roll = TRUE,
                    nomatch = NULL,
                    j = .(product_id, date, count, price)]
#    product_id       date count price
#         &lt;int&gt;     &lt;IDat&gt; &lt;int&gt; &lt;num&gt;
# 1:          2 2024-01-11   150  0.79
# 2:          1 2024-01-18    50  0.59
# 3:          1 2024-01-25   100  0.59
# 4:          2 2024-02-06   150  0.89
# 5:          1 2024-02-27   150  0.63
# 6:          1 2024-03-08    50  0.65
</code></pre>
<h2 id="sec:7-taking-advantage-of-joining-speed">7. Taking advantage of joining speed</h2>
<h3 id="sec:7-1-subsets-as-joins">7.1. Subsets as joins</h3>
<p>As we just saw in the prior section the <code>x</code> table gets filtered by the values available in the <code>i</code> table. This process is faster than passing a Boolean expression to the <code>i</code> argument.</p>
<p>To filter the <code>x</code> table at speed we donâ€™t need to pass a complete <code>data.table</code>, we can pass a <code>list()</code> of vectors with the values that we want to keep or omit from the original table.</p>
<p>For example, to filter dates where the market received 100 units of bananas (<code>product_id = 1</code>) or popcorn (<code>product_id = 3</code>) we can use the following:</p>
<pre><code class="language-r">ProductReceived[list(c(1L, 3L), 100L),
                on = c(&quot;product_id&quot;, &quot;count&quot;)]
#       id       date product_id count
#    &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt;
# 1:     2 2024-01-15          1   100
# 2:     9 2024-03-04          1   100
# 3:    NA       &lt;NA&gt;          3   100
</code></pre>
<p>As at the end, we are filtering based on a join operation the code returned a <strong>row that was not present in original table</strong>. To avoid that behavior, it is recommended to always add the argument <code>nomatch = NULL</code>.</p>
<pre><code class="language-r">ProductReceived[list(c(1L, 3L), 100L),
                on = c(&quot;product_id&quot;, &quot;count&quot;),
                nomatch = NULL]
#       id       date product_id count
#    &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt;
# 1:     2 2024-01-15          1   100
# 2:     9 2024-03-04          1   100
</code></pre>
<p>We can also use this technique to filter out any combination of values by prefixing them with <code>!</code> to negate the expression in the <code>i</code> argument and keeping the <code>nomatch</code> with its default value. For example, we can filter out the 2 rows we filtered before.</p>
<pre><code class="language-r">ProductReceived[!list(c(1L, 3L), 100L),
                on = c(&quot;product_id&quot;, &quot;count&quot;)]
#       id       date product_id count
#    &lt;int&gt;     &lt;IDat&gt;      &lt;int&gt; &lt;int&gt;
# 1:     1 2024-01-08         NA   150
# 2:     3 2024-01-22          6   100
# 3:     4 2024-01-29          1   150
# 4:     5 2024-02-05          2    50
# 5:     6 2024-02-12          1   150
# 6:     7 2024-02-19          2   150
# 7:     8 2024-02-26          2   100
# 8:    10 2024-03-11          3   150
</code></pre>
<p>If you just want to filter a value for a single <strong>character column</strong>, you can omit calling the <code>list()</code> function and pass the value to be filtered in the <code>i</code> argument.</p>
<pre><code class="language-r">Products[c(&quot;banana&quot;,&quot;popcorn&quot;),
         on = &quot;name&quot;,
         nomatch = NULL]
#       id    name price   unit      type
#    &lt;int&gt;  &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt;
# 1:     1  banana  0.63   unit   natural
# 2:     3 popcorn  2.99   unit processed

Products[!&quot;popcorn&quot;,
         on = &quot;name&quot;]
#       id       name price   unit      type
#    &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt;
# 1:     1     banana  0.63   unit   natural
# 2:     2    carrots  0.89     lb   natural
# 3:     4       soda  1.49  ounce processed
# 4:    NA toothpaste  2.99   unit processed
</code></pre>
<h3 id="sec:7-2-updating-by-reference">7.2. Updating by reference</h3>
<p>The <code>:=</code> operator in <code>data.table</code> is used for updating or adding columns by reference. This means it modifies the original <code>data.table</code> without creating a copy, which is very memory-efficient, especially for large datasets. When used inside a <code>data.table</code>, <code>:=</code> allows you to <strong>add new columns</strong> or <strong>modify existing ones</strong> as part of your query.</p>
<p>Letâ€™s update our <code>Products</code> table with the latest price from <code>ProductPriceHistory</code>:</p>
<pre><code class="language-r">copy(Products)[ProductPriceHistory,
               on = .(id = product_id),
               j = `:=`(price = tail(i.price, 1),
                        last_updated = tail(i.date, 1)),
               by = .EACHI][]
#       id       name price   unit      type last_updated
#    &lt;int&gt;     &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;char&gt;       &lt;IDat&gt;
# 1:     1     banana  0.65   unit   natural   2024-03-01
# 2:     2    carrots  0.99     lb   natural   2024-03-01
# 3:     3    popcorn  2.99   unit processed         &lt;NA&gt;
# 4:     4       soda  1.49  ounce processed         &lt;NA&gt;
# 5:    NA toothpaste  2.99   unit processed         &lt;NA&gt;
</code></pre>
<p>In this operation:</p>
<ul>
<li>The function copy creates a <em><strong>deep</strong></em> copy of the <code>Products</code> table, preventing modifications made by <code>:=</code> from changing the original table by reference.</li>
<li>We join <code>Products</code> with <code>ProductPriceHistory</code> based on <code>id</code> and <code>product_id</code>.</li>
<li>We update the <code>price</code> column with the latest price from <code>ProductPriceHistory</code>.</li>
<li>We add a new <code>last_updated</code> column to track when the price was last changed.</li>
<li>The <code>by = .EACHI</code> ensures that the <code>tail</code> function is applied for each product in <code>ProductPriceHistory</code>.</li>
</ul>
<hr />
<h2 id="sec:reference">Reference</h2>
<ul>
<li>
<p><em>Understanding data.table Rolling Joins</em>: <a href="https://www.r-bloggers.com/2016/06/understanding-data-table-rolling-joins/">https://www.r-bloggers.com/2016/06/understanding-data-table-rolling-joins/</a></p>
</li>
<li>
<p><em>Semi-join with data.table</em>: <a href="https://stackoverflow.com/questions/18969420/perform-a-semi-join-with-data-table">https://stackoverflow.com/questions/18969420/perform-a-semi-join-with-data-table</a></p>
</li>
<li>
<p><em>Cross join with data.table</em>: <a href="https://stackoverflow.com/questions/10600060/how-to-do-cross-join-in-r">https://stackoverflow.com/questions/10600060/how-to-do-cross-join-in-r</a></p>
</li>
<li>
<p><em>How does one do a full join using data.table?</em>: <a href="https://stackoverflow.com/questions/15170741/how-does-one-do-a-full-join-using-data-table">https://stackoverflow.com/questions/15170741/how-does-one-do-a-full-join-using-data-table</a></p>
</li>
<li>
<p><em>Enhanced data.frame</em>: <a href="https://rdatatable.gitlab.io/data.table/reference/data.table.html">https://rdatatable.gitlab.io/data.table/reference/data.table.html</a></p>
</li>
</ul>
</div>
</body>
</html>
